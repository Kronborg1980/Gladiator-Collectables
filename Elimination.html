<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Gladiators Death Arena: Final Showdown</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Bebas+Neue&family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* --- VISUAL CONFIGURATION --- */
        :root {
            --primary-glow: #00ffea; /* Cyan neon */
            --secondary-glow: #ff00ff; /* Magenta neon */
            --bg-dark: #0a0e1f; /* Deep space blue */
            --text-light: #f0f0f0; /* Soft white */
            --neon-red: #ff1744; /* Hot red */
            --neon-green: #00ff85; /* Bright green */
            --grid-color-dark: #1a2333; /* Darker grid */
            --status-bg-color: rgba(0, 255, 234, 0.1);
            --status-border-color: rgba(0, 255, 234, 0.5);
            --holo-blue: rgba(0, 255, 234, 0.3);
            --shadow-glow: 0 0 15px rgba(0, 255, 234, 0.5);
        }

        /* --- KEYFRAME ANIMATIONS (Modern Effects) --- */
        @keyframes scanlines {
            0% { background-position: 0 0; }
            100% { background-position: 0 50em; }
        }
        @keyframes flicker {
            0%, 18%, 22%, 25%, 53%, 57%, 100% { text-shadow: var(--shadow-glow), 0 0 20px var(--primary-glow); }
            20%, 24%, 55% { text-shadow: none; }
            58% { text-shadow: 0.5px 0 1px var(--secondary-glow), -0.5px 0 1px var(--neon-red); }
        }
        @keyframes canvas-flicker {
            0%, 100% { box-shadow: var(--shadow-glow); }
            50% { box-shadow: 0 0 10px var(--secondary-glow); }
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.01); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }

        /* --- CORE LAYOUT & SCALING FIXES --- */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background: radial-gradient(circle at center, #0c1426, var(--bg-dark));
            color: var(--text-light);
            font-family: 'Roboto Mono', monospace;
            overflow-x: hidden;
            overflow-y: auto;
            position: relative; /* Needed for scanlines */
        }
        /* Scanline and Noise Overlay */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.1;
            background: 
                /* Scanlines */
                linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.5) 50%),
                /* Noise */
                repeating-linear-gradient(transparent, transparent 1px, rgba(0, 0, 0, 0.2) 1px, rgba(0, 0, 0, 0.2) 2px);
            background-size: 100% 2px, 2px 2px;
            animation: scanlines 6s linear infinite;
        }

        #mainContainer {
            display: flex;
            flex-direction: column;
            min-height: 100vh; 
            padding: 20px;
            max-width: 1500px;
            margin: 0 auto;
            box-sizing: border-box;
        }

        /* --- TITLE --- */
        #titleContainer {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 25px; 
            gap: 15px;
            position: relative;
            z-index: 1200;
        }

        #titleContainer.game-active {
            justify-content: flex-start;
            margin-bottom: 10px;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            color: var(--primary-glow);
            /* Apply flicker animation */
            animation: flicker 4s linear infinite;
            letter-spacing: 5px;
            margin: 0;
            text-transform: uppercase;
            font-size: clamp(2.2em, 5vw, 3.5em);
            text-align: center;
            outline: 2px solid var(--primary-glow); 
            padding: 5px 20px;
        }

        #titleContainer.game-active h1 {
            font-size: clamp(1.6em, 3vw, 2.4em);
            letter-spacing: 3px;
        }

        /* --- SETUP PAGE (FRONT PAGE) --- */
        #frontPage {
            max-width: 900px;
            width: 100%;
            margin: 0 auto 30px;
            padding: 30px;
            background: rgba(10, 14, 31, 0.9);
            border-radius: 20px;
            border: 3px solid var(--primary-glow);
            box-shadow: var(--shadow-glow);
            text-align: center;
            animation: pulse 10s ease-in-out infinite; /* Subtle pulse effect */
        }

        #frontPage h2 {
            font-family: 'Orbitron', sans-serif;
            color: var(--secondary-glow);
            text-shadow: 0 0 10px var(--secondary-glow);
            margin: 0 0 20px;
            font-size: 2em;
        }

        .setup-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 500px;
            margin: 0 auto;
        }

        .input-card {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid var(--primary-glow);
            border-radius: 12px;
            padding: 20px;
            box-shadow: inset 0 0 10px rgba(0, 255, 234, 0.3);
            text-align: left; /* Alignment for input labels */
        }

        .input-card label {
            color: var(--text-light);
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 10px;
            display: block;
        }

        .input-card textarea {
            width: 100%;
            min-height: 120px;
            background: var(--bg-dark);
            color: var(--text-light);
            border: 2px solid var(--primary-glow);
            padding: 12px;
            border-radius: 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 1em;
            resize: none;
            box-sizing: border-box;
            transition: border-color 0.3s ease;
        }

        .input-card textarea:focus {
            outline: none;
            border-color: var(--secondary-glow);
            box-shadow: 0 0 10px var(--secondary-glow);
        }
        
        .range-container {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            padding-top: 5px;
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 8px;
            border: 1px dashed var(--secondary-glow);
        }

        .range-container label {
            text-align: center;
            margin-bottom: 0;
            font-size: 1em;
            color: var(--secondary-glow);
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 5px var(--secondary-glow);
        }

        .range-container input[type="range"] {
            width: 95%;
            -webkit-appearance: none;
            appearance: none;
            height: 10px;
            background: var(--grid-color-dark);
            border-radius: 5px;
            outline: none;
            opacity: 0.9;
            transition: opacity .2s;
            box-shadow: 0 0 5px var(--secondary-glow);
        }

        .range-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-glow);
            cursor: pointer;
            box-shadow: 0 0 10px var(--primary-glow);
        }

        .action-buttons {
             display: flex; 
             gap: 15px; 
             justify-content: center; 
             margin-top: 25px;
             flex-wrap: wrap;
        }

        .game-button {
            padding: 15px 35px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2em;
            text-transform: uppercase;
            background: linear-gradient(45deg, var(--primary-glow), var(--secondary-glow));
            color: var(--bg-dark);
            box-shadow: var(--shadow-glow);
            transition: all 0.3s ease;
        }

        .game-button:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 0 20px var(--primary-glow);
            filter: brightness(1.3);
        }
        
        .game-button.prepare-secondary {
            background: linear-gradient(45deg, #ff5500, #ff9900);
            color: var(--text-light);
            box-shadow: 0 0 15px #ff9900;
        }

        /* --- STATUS DISPLAY --- */
        #status {
            padding: 15px;
            background: var(--status-bg-color);
            border: 2px solid var(--status-border-color);
            border-radius: 10px;
            font-family: 'Roboto Mono', monospace;
            font-size: 1.1em;
            color: var(--text-light);
            text-shadow: 0 0 5px var(--primary-glow);
            margin-top: 20px;
        }

        /* --- GAME VIEW (DEATH ARENA) --- */
        #gameView {
            display: none;
            flex-direction: row;
            width: 100%;
            flex-grow: 1; 
            gap: 25px;
            height: 0; 
        }

        #sidePanel {
            display: flex;
            flex-direction: column;
            min-width: 300px;
            width: 30%;
            max-width: 400px;
            padding: 25px;
            background: rgba(10, 14, 31, 0.85);
            border-radius: 15px;
            border: 2px solid var(--primary-glow);
            box-shadow: var(--shadow-glow);
            overflow-y: auto;
            flex-shrink: 0;
            height: 100%; 
            box-sizing: border-box;
        }

        #canvasWrapper {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            height: 100%; 
            min-height: 400px;
        }

        /* Holographic Frame Effect around Canvas */
        #canvasWrapper::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 8px solid rgba(0, 255, 234, 0.1);
            border-radius: 20px;
            pointer-events: none;
            box-sizing: border-box;
            opacity: 0.5;
            z-index: 10;
            /* Thin dashed border for technical look */
            border-style: dashed;
            animation: pulse 4s ease-in-out infinite;
        }

        #gameCanvas {
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 1 / 1;
            border: 4px solid var(--primary-glow);
            box-shadow: var(--shadow-glow);
            background: var(--grid-color-dark);
            z-index: 11;
            position: relative;
            animation: canvas-flicker 5s ease-in-out infinite;
        }

        /* Info Panel & List */
        #infoPanel {
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid var(--primary-glow);
            margin-bottom: 20px;
        }

        #infoPanel h4 {
            color: var(--secondary-glow);
            margin: 0 0 10px;
            font-size: 1.4em;
            font-family: 'Orbitron', sans-serif;
            text-shadow: 0 0 8px var(--secondary-glow);
        }

        #currentRacersList {
            list-style: none;
            padding: 0;
            margin: 10px 0 0;
            max-height: 200px;
            overflow-y: auto;
            border-top: 1px solid var(--primary-glow);
            padding-top: 10px;
        }

        #currentRacersList li {
            padding: 8px 0;
            font-size: 1em;
            color: var(--text-light);
            font-family: 'Roboto Mono', monospace;
        }

        .eliminated-racer {
            color: var(--neon-red);
            text-decoration: line-through;
            opacity: 0.7;
        }

        .eliminated-racer:before {
            content: "üíÄ";
            margin-right: 8px;
        }

        #attackStatus {
            font-size: 2em;
            color: var(--neon-red);
            text-shadow: 0 0 15px var(--neon-red);
            margin: 10px 0;
            text-align: center;
            font-family: 'Orbitron', sans-serif;
        }

        #scoreDisplay {
            font-size: 1.2em;
            color: var(--neon-green);
            text-shadow: 0 0 8px var(--neon-green);
            margin: 10px 0;
            text-align: center;
            font-family: 'Orbitron', sans-serif;
        }

        /* --- WINNER OVERLAY --- */
        #winnerOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: var(--primary-glow);
            font-family: 'Orbitron', sans-serif;
            text-shadow: var(--shadow-glow);
            z-index: 2000;
        }

        #winnerOverlay h2 {
            font-size: 3em;
            margin: 10px 0;
            color: var(--secondary-glow);
        }

        #winnerName {
            font-size: 2.5em;
            color: var(--neon-green);
            text-shadow: 0 0 15px var(--neon-green);
        }

        /* --- RESPONSIVE LAYOUT --- */
        @media (max-width: 768px) {
            #titleContainer.game-active {
                flex-direction: column;
                text-align: center;
                margin-bottom: 20px;
            }

            #gameView {
                flex-direction: column;
                gap: 20px;
                height: auto; 
            }

            #sidePanel {
                width: 100%;
                max-width: none;
                max-height: 50vh; 
                height: auto;
            }

            #canvasWrapper {
                min-height: 300px;
                height: 100vw;
            }
        }
    </style>
</head>
<body>
    <audio id="explosionSound" src="https://freesound.org/data/previews/171/171671_3025331-lq.mp3"></audio>
    <div id="mainContainer">
        <div id="titleContainer">
            <h1>GLADIATORS DEATH ARENA</h1>
        </div>
        <div id="frontPage">
            <h2>LAST POK√âMON STANDING SETUP</h2>
            <div class="setup-grid">
                <div class="input-card">
                    <label for="racerNames">Contender Names (one per line, **Max 151 Gladiators**):</label>
                    <textarea id="racerNames" rows="5" placeholder="Ash\nMisty\nBrock\nGary\nLance\nSabrina\nGiovanni\nBlue"></textarea>
                </div>
            </div>
            <div class="action-buttons">
                <button id="submitNamesButton" class="game-button">SUBMIT CONTENDERS</button>
                <button id="setupStartButton" class="game-button prepare-secondary">PREPARE ARENA</button>
            </div>
            <div id="status">Arena online. Enter contenders and submit to begin.</div>
        </div>
        <div id="gameView">
            <div id="sidePanel">
                <div id="infoPanel">
                    <h4>ARENA CORE | ROUND: <span id="roundDisplay">N/A</span></h4>
                    <p>Attack Protocol: <strong id="attackTypeDisplay" style="color: var(--neon-red);">Neutral</strong> (Pattern: <span id="attackPatternDisplay">Aura Scan</span>)</p>
                    <p>Score: <strong id="scoreDisplay">0</strong></p>
                    <p>Active Contenders:</p>
                    <ul id="currentRacersList"></ul>
                    <p style="margin-top: 15px; font-size: 0.9em; text-align: center; border-top: 1px solid var(--primary-glow); padding-top: 10px;">
                        Battle Key: <span style="color: var(--neon-green); text-shadow: 0 0 5px var(--neon-green);">‚≠ê Immune</span> / <span style="color: var(--secondary-glow); text-shadow: 0 0 5px var(--secondary-glow);">‚ú® Evasion</span>
                    </p>
                </div>
                <div id="statusContainer">
                    <div id="attackStatus"></div>
                    <div id="status" style="margin-top: 15px;">Initializing Battle...</div>
                </div>
                <div id="gameControls" style="display: flex; flex-direction: column; gap: 15px; flex-grow: 1; justify-content: flex-end;">
                    
                    <div class="range-container">
                        <label for="eliminationTimer">MOVE PHASE TIMER: <span id="timerValueDisplay">3s</span></label>
                        <input type="range" id="eliminationTimer" min="1000" max="10000" value="3000" step="1000">
                    </div>
                    <button id="shuffleButton" class="game-button">SHUFFLE POK√âMON</button>
                    <button id="startGameButton" class="game-button">LAUNCH BATTLE</button>
                    <button onclick="resetGame()" class="game-button prepare-secondary">RESET ARENA</button>
                </div>
            </div>
            <div id="canvasWrapper">
                <canvas id="gameCanvas" width="600" height="600"></canvas>
            </div>
        </div>
        <div id="winnerOverlay">
            <h2>VICTOR EMERGES!</h2>
            <span id="winnerName"></span>
            <p>Final Score: <span id="finalScore"></span></p>
            <button onclick="resetGame()" class="game-button" style="margin-top: 30px;">NEW BATTLE</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const setupControls = document.getElementById('frontPage');
        const gameView = document.getElementById('gameView');
        const submitNamesButton = document.getElementById('submitNamesButton');
        const setupStartButton = document.getElementById('setupStartButton');
        const startGameButton = document.getElementById('startGameButton');
        const shuffleButton = document.getElementById('shuffleButton');
        const statusDisplay = document.getElementById('status');
        const titleContainer = document.getElementById('titleContainer');
        const roundDisplay = document.getElementById('roundDisplay');
        const attackTypeDisplay = document.getElementById('attackTypeDisplay');
        const attackPatternDisplay = document.getElementById('attackPatternDisplay');
        const currentRacersList = document.getElementById('currentRacersList');
        const winnerOverlay = document.getElementById('winnerOverlay');
        const winnerNameDisplay = document.getElementById('winnerName');
        const finalScoreDisplay = document.getElementById('finalScore');
        const attackStatus = document.getElementById('attackStatus');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const explosionSound = document.getElementById('explosionSound');

        // TIMER ELEMENTS
        const eliminationTimerInput = document.getElementById('eliminationTimer');
        const timerValueDisplay = document.getElementById('timerValueDisplay');
        
        const GRID_SIZE = 10;
        let TILE_SIZE = canvas.width / GRID_SIZE;
        let POKEMON_IMAGE_SIZE = TILE_SIZE * 0.85;
        
        // Timer variable controlled by the new slider (in milliseconds)
        let ELIMINATION_TIMER_MS = parseInt(eliminationTimerInput.value); 
        
        // Duration of the blink effect
        const BLINK_DURATION = 100; // milliseconds for the flash
        const CAPTURE_DURATION = 1100; // milliseconds for the post-blink animation

        const GAME_STATES = { SETUP: 'SETUP', PREPARING: 'PREPARING', PLAYING: 'PLAYING', FINISHED: 'FINISHED' };
        let gameState = GAME_STATES.SETUP;
        let racers = [];
        let roundNumber = 0;
        let gameScore = 0;
        let gameLoopInterval;
        let roundPhase = 0; // 0: Move, 1: Warning/Attack, 2: Resolution
        
        // Use a function for PHASE_TIMINGS to dynamically update the first value
        const getPhaseTimings = () => [ELIMINATION_TIMER_MS, 1500, 1200]; 

        const POKEBALL_URL = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/poke-ball.png';
        const POKEBALL_IMAGE = new Image();
        POKEBALL_IMAGE.src = POKEBALL_URL;
        
        const POKEMON_TYPES = ['Grass', 'Fire', 'Water', 'Electric', 'Ground', 'Fighting', 'Flying', 'Psychic'];
        const ATTACK_PATTERNS = {
            'Earthquake': { type: 'Ground', name: 'Seismic Overload' },
            'Thunder Wave': { type: 'Electric', name: 'Volt Surge' },
            'Hydro Pump': { type: 'Water', name: 'Aqua Barrage' },
            'Fire Blast': { type: 'Fire', name: 'Inferno Strike' },
            'Psychic Surge': { type: 'Psychic', name: 'Psyonic Pulse' }
        };
        
        const pokemonData = [];
        for (let id = 1; id <= 151; id++) {
            pokemonData.push({
                id, name: `Poke ${id}`,
                imageGif: `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/${id}.gif`,
                sprite: null
            });
        }
        pokemonData.forEach(p => {
            const img = new Image();
            img.onload = () => { p.sprite = img; };
            img.src = p.imageGif;
        });

        let currentAttack = { type: 'Neutral', name: 'Aura Scan', targetRacer: null, dodgeEffect: false };
        let availableAttacks = Object.keys(ATTACK_PATTERNS);

        function playExplosion() {
            explosionSound.currentTime = 0;
            explosionSound.play().catch(e => console.error("Audio playback failed:", e));
        }

        function updateCanvasSize() {
            const wrapper = document.getElementById('canvasWrapper');
            const size = Math.min(wrapper.clientWidth, wrapper.clientHeight);
            canvas.width = size;
            canvas.height = size;
            TILE_SIZE = canvas.width / GRID_SIZE;
            POKEMON_IMAGE_SIZE = TILE_SIZE * 0.85;
        }

        function drawGame() {
            updateCanvasSize();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.fillStyle = 'var(--grid-color-dark)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = 'var(--primary-glow)';
            ctx.shadowColor = 'var(--primary-glow)';
            ctx.shadowBlur = 10;
            ctx.lineWidth = 1.5;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * TILE_SIZE, 0);
                ctx.lineTo(i * TILE_SIZE, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * TILE_SIZE);
                ctx.lineTo(canvas.width, i * TILE_SIZE);
                ctx.stroke();
            }
            ctx.shadowBlur = 0;

            // Draw target visualization
            if (currentAttack.targetRacer && currentAttack.targetRacer.active && (roundPhase === 1 || roundPhase === 2)) {
                const r = currentAttack.targetRacer;
                const xCenter = r.x * TILE_SIZE + TILE_SIZE / 2;
                const yCenter = r.y * TILE_SIZE + TILE_SIZE / 2;
                
                // Control blink rate: Phase 1 is 1500ms. Blink cycle is 500ms (250ms ON, 250ms OFF). 
                const PHASE_TIMINGS = getPhaseTimings();
                const timeElapsedInPhase1 = Date.now() - r.roundStartTime - PHASE_TIMINGS[0];
                let flash = 0;
                
                if (roundPhase === 1 && timeElapsedInPhase1 < PHASE_TIMINGS[1]) {
                    const timeInCycle = timeElapsedInPhase1 % 500;
                    if (timeInCycle < 250) {
                        flash = 0.8;
                    } else {
                        flash = 0.0;
                    }
                } else if (roundPhase === 2) {
                    flash = 0; // Hide targeting during resolution animation
                }

                // Laser targeting circle - only draw when flash is on
                if (flash > 0) {
                    ctx.beginPath();
                    ctx.arc(xCenter, yCenter, TILE_SIZE * 0.5, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255, 0, 0, ${flash})`;
                    ctx.lineWidth = 4;
                    ctx.shadowColor = 'var(--neon-red)';
                    ctx.shadowBlur = 15;
                    ctx.stroke();

                    // Crosshair X
                    ctx.beginPath();
                    const halfSize = POKEMON_IMAGE_SIZE * 0.5;
                    ctx.moveTo(xCenter - halfSize, yCenter - halfSize);
                    ctx.lineTo(xCenter + halfSize, yCenter + halfSize);
                    ctx.moveTo(xCenter + halfSize, yCenter - halfSize);
                    ctx.lineTo(xCenter - halfSize, yCenter + halfSize);
                    ctx.strokeStyle = `rgba(255, 0, 0, ${flash})`;
                    ctx.lineWidth = 6;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }

            // Draw racers with enhanced visuals
            racers.filter(r => r.active).forEach(r => {
                const x = r.x * TILE_SIZE + TILE_SIZE / 2;
                const y = r.y * TILE_SIZE + TILE_SIZE / 2;
                const nameText = `${r.name} (${r.data.type})`;
                ctx.save();
                ctx.translate(x, y);

                // Holographic base effect
                ctx.beginPath();
                ctx.arc(0, 0, TILE_SIZE * 0.45, 0, Math.PI * 2);
                ctx.fillStyle = 'var(--holo-blue)';
                ctx.fill();

                // Immunity/Evasion glow
                if (r.isSafe) {
                    ctx.beginPath();
                    ctx.arc(0, 0, TILE_SIZE * 0.4, 0, Math.PI * 2);
                    ctx.fillStyle = r.isSafe === 'IMMUNE' ? 'rgba(240,255,0,0.4)' : 'rgba(0,255,133,0.4)';
                    ctx.fill();
                    ctx.strokeStyle = r.isSafe === 'IMMUNE' ? 'var(--neon-green)' : 'var(--secondary-glow)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                // **Capture Blink Logic:** Only draw the Pokemon if NOT in the blink phase.
                let isCapturing = r.captureAnimation && (Date.now() - r.captureStartTime < CAPTURE_DURATION);
                let isBlinking = isCapturing && (Date.now() - r.captureStartTime < BLINK_DURATION);
                
                if (!isCapturing || (isCapturing && !isBlinking)) {
                    // Draw Pok√©mon sprite
                    if (r.data.sprite && r.data.sprite.complete) {
                        ctx.drawImage(r.data.sprite, -POKEMON_IMAGE_SIZE / 2, -POKEMON_IMAGE_SIZE / 2, POKEMON_IMAGE_SIZE, POKEMON_IMAGE_SIZE);
                    }
                }
                
                // Draw name tag (White with Black Border for visibility)
                ctx.font = `bold ${TILE_SIZE * 0.28}px 'Bebas Neue', sans-serif`;
                ctx.textAlign = 'center'; 
                ctx.fillStyle = 'white';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 6; 
                
                ctx.strokeText(nameText, 0, -TILE_SIZE / 1.8);
                ctx.fillText(nameText, 0, -TILE_SIZE / 1.8);

                ctx.restore();
            });

            // --- Capture Animation ---
            racers.filter(r => r.captureAnimation).forEach(r => {
                const x = r.x * TILE_SIZE + TILE_SIZE / 2;
                const y = r.y * TILE_SIZE + TILE_SIZE / 2;
                const animationTime = Date.now() - r.captureStartTime;
                ctx.save();
                ctx.translate(x, y);

                // 1. **THE BLINK (First BLINK_DURATION milliseconds)**
                if (animationTime < BLINK_DURATION) {
                    ctx.beginPath();
                    ctx.arc(0, 0, TILE_SIZE * 1.5, 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 1)'; 
                    ctx.shadowColor = 'var(--neon-red)';
                    ctx.shadowBlur = 40;
                    ctx.fill();
                } 
                // 2. **THE CATCH (Rest of the duration)**
                else if (animationTime < CAPTURE_DURATION) {
                    const progress = (animationTime - BLINK_DURATION) / (CAPTURE_DURATION - BLINK_DURATION);
                    
                    // Pok√© Ball slamming down
                    const ballSize = POKEMON_IMAGE_SIZE * 1.6;
                    const scale = 1 + Math.sin(progress * Math.PI) * 0.3;
                    ctx.globalAlpha = 1 - progress;
                    ctx.drawImage(POKEBALL_IMAGE, -ballSize * scale / 2, -ballSize * scale / 2, ballSize * scale, ballSize * scale);

                    // Sucking in effect (magenta glow)
                    ctx.beginPath();
                    ctx.arc(0, 0, POKEMON_IMAGE_SIZE * (1.2 - progress), 0, Math.PI * 2);
                    ctx.fillStyle = 'var(--secondary-glow)';
                    ctx.globalAlpha = 0.5 * (1 - progress);
                    ctx.fill();
                }
                
                ctx.restore();
                ctx.globalAlpha = 1.0;
            });
        }

        function startRound() {
            const activeRacers = racers.filter(r => r.active);
            if (activeRacers.length <= 1) {
                endGame(activeRacers[0]);
                return;
            }
            roundNumber++;
            roundPhase = 0;
            gameScore += 100; // Score for surviving a round
            
            const PHASE_TIMINGS = getPhaseTimings(); // Get current phase timings
            
            // Set round start time for blink logic
            racers.forEach(r => {
                r.targetX = r.x;
                r.targetY = r.y;
                r.isSafe = null;
                r.captureAnimation = false;
                r.roundStartTime = Date.now(); 
            });
            updateRacerListDisplay();
            updateScoreDisplay();

            const attackName = availableAttacks[Math.floor(Math.random() * availableAttacks.length)];
            const attackConfig = ATTACK_PATTERNS[attackName];
            currentAttack.name = attackName;
            currentAttack.type = attackConfig.type;
            currentAttack.dodgeEffect = (currentAttack.type === 'Water' || currentAttack.type === 'Fire');
            currentAttack.targetRacer = activeRacers[Math.floor(Math.random() * activeRacers.length)];

            updateGameInfo();
            attackStatus.textContent = '';
            // Use the dynamic ELIMINATION_TIMER_MS value for the status message
            statusDisplay.textContent = `ROUND ${roundNumber} - MOVE PHASE: ${ELIMINATION_TIMER_MS / 1000}s to evade!`;

            setTimeout(attackPhase, PHASE_TIMINGS[0]);
            drawGame();
        }

        function attackPhase() {
            roundPhase = 1;
            const PHASE_TIMINGS = getPhaseTimings();
            const targetName = currentAttack.targetRacer ? currentAttack.targetRacer.name : 'N/A';
            attackStatus.textContent = `‚ö† ${targetName} TARGETED!`;
            statusDisplay.textContent = `ROUND ${roundNumber} - ${ATTACK_PATTERNS[currentAttack.name].name} DEPLOYING!`;
            updateGameInfo();
            drawGame();
            setTimeout(resolutionPhase, PHASE_TIMINGS[1]);
        }

        function resolutionPhase() {
            roundPhase = 2;
            const PHASE_TIMINGS = getPhaseTimings();
            attackStatus.textContent = '';
            const r = currentAttack.targetRacer;

            if (r.active) {
                r.x = r.targetX;
                r.y = r.targetY;
                let captured = true;
                let reason = currentAttack.type;

                // Immunity check
                const type = r.data.type;
                if ((currentAttack.type === 'Ground' && (type === 'Flying' || type === 'Grass')) ||
                    (currentAttack.type === 'Electric' && type === 'Ground')) {
                    r.isSafe = 'IMMUNE';
                    captured = false;
                    reason = `IMMUNE (${type})`;
                    gameScore += 200; // Bonus for immunity
                }
                // Evasion check
                else if (currentAttack.dodgeEffect && (type === 'Water' || type === 'Fire')) {
                    if (Math.random() < 0.5) {
                        captured = false;
                        r.isSafe = 'EVADED';
                        reason = `EVADED (${type})`;
                        gameScore += 150; // Bonus for evasion
                    } else {
                        reason = `CAUGHT (Failed Evasion)`;
                    }
                } else {
                    reason = `CAUGHT (${currentAttack.type} Hit)`;
                }

                if (captured) {
                    // Start the capture animation (first frame is the flash/blink)
                    r.captureAnimation = true;
                    r.captureStartTime = Date.now();
                    r.eliminationReason = reason;
                    playExplosion();

                    // Final elimination occurs after the animation finishes
                    setTimeout(() => {
                        r.active = false;
                        r.captureAnimation = false;
                        statusDisplay.textContent = `üí• ${r.name} ELIMINATED!`;
                        updateRacerListDisplay();
                        updateScoreDisplay();
                        setTimeout(startRound, 200);
                    }, CAPTURE_DURATION);
                } else {
                    statusDisplay.textContent = `‚úÖ ${r.name} survived! Reason: ${reason}`;
                    updateRacerListDisplay();
                    updateScoreDisplay();
                    setTimeout(startRound, 200);
                }
            } else {
                setTimeout(startRound, 50);
            }
        }

        function endGame(winner) {
            gameState = GAME_STATES.FINISHED;
            winnerNameDisplay.textContent = winner ? `${winner.name}` : "NO VICTOR!";
            finalScoreDisplay.textContent = gameScore;
            winnerOverlay.style.display = 'flex';
            statusDisplay.textContent = `BATTLE TERMINATED! ${winner ? winner.name : 'All'} survived ${roundNumber} rounds. Score: ${gameScore}`;
            titleContainer.classList.remove('game-active');
            clearInterval(gameLoopInterval);
        }

        function updateRacerListDisplay() {
            currentRacersList.innerHTML = racers.map(r => {
                const isEliminated = !r.active;
                let display = `${r.name} (${r.data.type})`;
                if (isEliminated) {
                    display += ` - ${r.eliminationReason || 'Eliminated'}`;
                } else if (currentAttack.targetRacer === r && roundPhase !== 0) {
                    display = `<strong style="color: var(--neon-red);">üî• ${display} üî•</strong>`;
                }
                return `<li class="${isEliminated ? 'eliminated-racer' : ''}">${display}</li>`;
            }).join('');
        }

        function updateGameInfo() {
            roundDisplay.textContent = `#${roundNumber}`;
            attackTypeDisplay.textContent = currentAttack.type;
            attackPatternDisplay.textContent = ATTACK_PATTERNS[currentAttack.name].name;
        }

        function updateScoreDisplay() {
            scoreDisplay.textContent = gameScore;
        }

        function submitNames() {
            initRacers(true);
            if (racers.length === 0) {
                statusDisplay.textContent = 'Enter at least one contender name.';
                return;
            }
            updateRacerListDisplay();
            statusDisplay.textContent = `${racers.length} contenders locked in. Activate Arena!`;
            drawGame();
        }

        function prepareGame() {
            if (racers.length < 2) {
                statusDisplay.textContent = 'Require at least 2 contenders to initiate Battle!';
                return;
            }
            gameState = GAME_STATES.PREPARING;
            setupControls.style.display = 'none';
            gameView.style.display = 'flex';
            titleContainer.classList.add('game-active');
            statusDisplay.textContent = 'CONFIGURE: Shuffle Pok√©mon, then launch battle.';
            updateCanvasSize();
            drawGame();
        }

        function startGame() {
            gameState = GAME_STATES.PLAYING;
            setupControls.style.display = 'none';
            startGameButton.style.display = 'none';
            shuffleButton.style.display = 'none';
            gameScore = 0;
            updateScoreDisplay();
            startRound();
        }

        function resetGame() {
            gameState = GAME_STATES.SETUP;
            roundNumber = 0;
            gameScore = 0;
            currentAttack = { type: 'Neutral', name: 'Aura Scan', targetRacer: null, dodgeEffect: false };
            winnerOverlay.style.display = 'none';
            setupControls.style.display = 'block';
            gameView.style.display = 'none';
            titleContainer.classList.remove('game-active');
            updateGameInfo();
            updateScoreDisplay();
            currentRacersList.innerHTML = '';
            statusDisplay.textContent = 'Arena online. Enter contenders to begin.';
            initRacers(false);
            startGameButton.style.display = 'block';
            shuffleButton.style.display = 'block';
            drawGame();
            gameLoopInterval = setInterval(moveAI, 100);
        }

        function moveAI() {
            if (gameState !== GAME_STATES.PLAYING || roundPhase !== 0) return;
            racers.filter(r => r.active).forEach(r => {
                const availableMoves = [];
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const newX = r.x + dx;
                        const newY = r.y + dy;
                        if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
                            availableMoves.push({ x: newX, y: newY });
                        }
                    }
                }
                if (availableMoves.length > 0) {
                    const randomMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
                    r.targetX = randomMove.x;
                    r.targetY = randomMove.y;
                }
            });
            drawGame();
        }

        function initRacers(fromSetup = true) {
            racers = [];
            const customNamesInput = document.getElementById('racerNames');
            let customNames = customNamesInput.value.split('\n').map(name => name.trim()).filter(name => name);
            
            if (customNames.length === 0 && fromSetup) return;
            
            const shuffledPokemon = [...pokemonData].sort(() => 0.5 - Math.random());
            const numRacers = Math.min(customNames.length, shuffledPokemon.length); 
            
            const usedTiles = new Set();
            for (let i = 0; i < numRacers; i++) {
                let x, y, posKey;
                do {
                    x = Math.floor(Math.random() * GRID_SIZE);
                    y = Math.floor(Math.random() * GRID_SIZE);
                    posKey = `${x},${y}`;
                } while (usedTiles.has(posKey));
                usedTiles.add(posKey);
                racers.push({
                    name: customNames[i],
                    data: { ...shuffledPokemon[i], type: POKEMON_TYPES[i % POKEMON_TYPES.length] },
                    active: true,
                    x: x,
                    y: y,
                    targetX: x,
                    targetY: y,
                    isSafe: null,
                    captureAnimation: false,
                    eliminationReason: null,
                    roundStartTime: Date.now() // Initialize round start time
                });
            }
            if (racers.length > 0) reassignPokemons(false);
        }

        function reassignPokemons(updateDisplay = true) {
            if (racers.length === 0) return;
            const shuffledPokemon = [...pokemonData].sort(() => 0.5 - Math.random());
            const shuffledTypes = [...POKEMON_TYPES].sort(() => 0.5 - Math.random());
            const usedTiles = new Set();

            racers.forEach((racer, i) => {
                // 1. Assign new type and sprite
                const newPoke = shuffledPokemon[i % shuffledPokemon.length];
                const newType = shuffledTypes[i % shuffledTypes.length];
                racer.data = { ...newPoke, type: newType };

                // 2. Assign new random position (positional shuffle)
                let x, y, posKey;
                do {
                    x = Math.floor(Math.random() * GRID_SIZE);
                    y = Math.floor(Math.random() * GRID_SIZE);
                    posKey = `${x},${y}`;
                } while (usedTiles.has(posKey));
                usedTiles.add(posKey);
                
                racer.x = x;
                racer.y = y;
                racer.targetX = x;
                racer.targetY = y;
            });

            if (updateDisplay) {
                updateRacerListDisplay();
                statusDisplay.textContent = `${racers.length} contenders shuffled and repositioned. Ready to launch!`;
            }
            drawGame();
        }
        
        // --- TIMER CONTROL LOGIC ---
        eliminationTimerInput.addEventListener('input', (event) => {
            ELIMINATION_TIMER_MS = parseInt(event.target.value);
            // Display the value in seconds
            timerValueDisplay.textContent = `${ELIMINATION_TIMER_MS / 1000}s`; 
        });
        // --- END TIMER CONTROL LOGIC ---

        // Initial update of the display to match the default value
        timerValueDisplay.textContent = `${ELIMINATION_TIMER_MS / 1000}s`; 

        submitNamesButton.addEventListener('click', submitNames);
        setupStartButton.addEventListener('click', prepareGame);
        startGameButton.addEventListener('click', startGame);
        shuffleButton.addEventListener('click', () => reassignPokemons(true));
        window.addEventListener('resize', drawGame);
        gameLoopInterval = setInterval(moveAI, 100);
        setInterval(drawGame, 30);
        initRacers(false);
        drawGame();
    </script>
</body>
</html>
