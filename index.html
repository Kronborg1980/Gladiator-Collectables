<!DOCTYPE html>
<html lang="en">
<head>
Â  Â  <meta charset="utf-8" />
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1" />
Â  Â  <title>PokÃ©mon Capture Chaos: ULTIMATE SHOWDOWN</title>
Â  Â  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Bebas+Neue&display=swap" rel="stylesheet">
Â  Â  <style>
Â  Â  Â  Â  :root{
Â  Â  Â  Â  Â  Â  /* Neon Blue Aesthetic */
Â  Â  Â  Â  Â  Â  --primary-glow: #e0e0e0;
Â  Â  Â  Â  Â  Â  --secondary-glow: #00eaff; /* NEON BLUE */
Â  Â  Â  Â  Â  Â  --bg-dark: #0d121f;Â 
Â  Â  Â  Â  Â  Â  --text-light: #f0ff00;
Â  Â  Â  Â  Â  Â  --neutral-dark: #333;
Â  Â  Â  Â  Â  Â  --neutral-medium: #555;
Â  Â  Â  Â  Â  Â  --neutral-light: #bbb;
Â  Â  Â  Â  Â  Â  --racer-name-color: #FFFFFF;
Â  Â  Â  Â  Â  Â  --prepare-color: #ff5500;
Â  Â  Â  Â  Â  Â  --neon-red: #ff1744;
Â  Â  Â  Â  Â  Â  --grid-color-dark: #1f3b4c;Â 
Â  Â  Â  Â  }
Â  Â  Â  Â  html,body{
Â  Â  Â  Â  Â  Â  height:100%;
Â  Â  Â  Â  Â  Â  margin:0;
Â  Â  Â  Â  Â  Â  padding:0;
Â  Â  Â  Â  Â  Â  background: linear-gradient(135deg, var(--bg-dark), #010a14, var(--bg-dark));
Â  Â  Â  Â  Â  Â  color: var(--text-light);
Â  Â  Â  Â  Â  Â  font-family: 'Bebas Neue', sans-serif;
Â  Â  Â  Â  Â  Â  -webkit-font-smoothing:antialiased;
Â  Â  Â  Â  Â  Â  -moz-osx-font-smoothing:grayscale;
Â  Â  Â  Â  }
Â  Â  Â  Â  #titleContainer{
Â  Â  Â  Â  Â  Â  display:flex; flex-direction:column; align-items:center; justify-content:center;
Â  Â  Â  Â  Â  Â  margin: 18px 0 6px; gap:6px; position: relative; z-index: 1200;
Â  Â  Â  Â  }
Â  Â  Â  Â  #titleContainer.game-active { display: none; }
Â  Â  Â  Â  h1{
Â  Â  Â  Â  Â  Â  font-family:'Orbitron',sans-serif; color: var(--secondary-glow);
Â  Â  Â  Â  Â  Â  text-shadow:0 0 15px var(--secondary-glow), 0 0 30px var(--secondary-glow);
Â  Â  Â  Â  Â  Â  letter-spacing:4px; margin:0; text-transform:uppercase;
Â  Â  Â  Â  Â  Â  font-size: clamp(1.6em, 3.8vw, 2.8em); text-align:center;
Â  Â  Â  Â  }
Â  Â  Â  Â  #frontPage{
Â  Â  Â  Â  Â  Â  max-width:950px; margin:0 auto; padding:20px;
Â  Â  Â  Â  Â  Â  background: linear-gradient(135deg, rgba(10,10,10,0.8), rgba(26,26,26,0.9));
Â  Â  Â  Â  Â  Â  border-radius:20px; border:2px solid var(--secondary-glow);
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 30px rgba(0, 234, 255, 0.3);
Â  Â  Â  Â  Â  Â  text-align:center;
Â  Â  Â  Â  }
Â  Â  Â  Â  .setup-grid{
Â  Â  Â  Â  Â  Â  display:grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
Â  Â  Â  Â  Â  Â  gap:20px; margin-bottom:20px;
Â  Â  Â  Â  }
Â  Â  Â  Â  .input-card{
Â  Â  Â  Â  Â  Â  background: rgba(0,0,0,0.5); border:1px solid var(--neutral-medium);
Â  Â  Â  Â  Â  Â  border-radius:12px; padding:15px; box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
Â  Â  Â  Â  }
Â  Â  Â  Â  .input-card label{
Â  Â  Â  Â  Â  Â  display:block; margin-bottom:8px; color:var(--neutral-light);
Â  Â  Â  Â  Â  Â  font-size:0.9em; font-weight:bold;
Â  Â  Â  Â  }
Â  Â  Â  Â  .input-card textarea{ resize:vertical; min-height:120px; }
Â  Â  Â  Â  .action-buttons{ display:flex; justify-content:center; gap:15px; margin:20px 0; flex-wrap:wrap; }
Â  Â  Â  Â  .game-button{
Â  Â  Â  Â  Â  Â  padding: 15px 35px; border:none; border-radius:10px; cursor:pointer;
Â  Â  Â  Â  Â  Â  font-weight:bold; font-size:1.1em; transition: all 0.3s;
Â  Â  Â  Â  Â  Â  background: linear-gradient(45deg, var(--secondary-glow), #00aaff);
Â  Â  Â  Â  Â  Â  color:#111; box-shadow: 0 5px 15px rgba(0, 234, 255, 0.35), 0 0 20px rgba(0, 234, 255, 0.1);
Â  Â  Â  Â  Â  Â  text-shadow: 1px 1px 0 rgba(255,255,255,0.2);
            /* Ensure anchor tags also get button styling */
            text-decoration: none;
            display: inline-block;
            margin: 0 7.5px; /* Adjust margin for flex layout */
Â  Â  Â  Â  }
Â  Â  Â  Â  .game-button:hover{ transform:translateY(-3px); box-shadow: 0 8px 25px rgba(0, 234, 255, 0.5), 0 0 30px rgba(0, 234, 255, 0.2); }
Â  Â  Â  Â  .game-button.prepare{
Â  Â  Â  Â  Â  Â  background: linear-gradient(45deg, var(--neon-red), #ff4081);
Â  Â  Â  Â  Â  Â  color: var(--text-light); box-shadow: 0 5px 15px rgba(255, 23, 68, 0.6), 0 0 20px rgba(255, 23, 68, 0.3);
Â  Â  Â  Â  }
Â  Â  Â  Â  #status{
Â  Â  Â  Â  Â  Â  padding:12px; background:rgba(0, 234, 255, 0.1); border:1px solid var(--secondary-glow);
Â  Â  Â  Â  Â  Â  border-radius:8px; font-family: 'Orbitron', sans-serif; font-size:1.1em;
Â  Â  Â  Â  Â  Â  color: var(--primary-glow); text-shadow: 0 0 6px var(--primary-glow); margin-top:15px;
Â  Â  Â  Â  }
Â  Â  Â  Â  #gameView{
Â  Â  Â  Â  Â  Â  width:100%; max-width:800px; margin:20px auto; display:none; min-width:300px;
Â  Â  Â  Â  Â  Â  position: relative; text-align: center;
Â  Â  Â  Â  }
Â  Â  Â  Â  #gameControls {
Â  Â  Â  Â  Â  Â  margin: 15px 0; display: flex; justify-content: center; gap: 10px; flex-wrap: wrap;
Â  Â  Â  Â  }
Â  Â  Â  Â  #gameCanvas {
Â  Â  Â  Â  Â  Â  image-rendering: pixelated;Â 
Â  Â  Â  Â  Â  Â  border: 4px solid var(--secondary-glow);
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 25px var(--secondary-glow);
Â  Â  Â  Â  Â  Â  background-color: var(--grid-color-dark);
Â  Â  Â  Â  }
Â  Â  Â  Â  #infoPanel {
Â  Â  Â  Â  Â  Â  background: linear-gradient(135deg, rgba(0,0,0,0.8), rgba(26,26,26,0.9));Â 
Â  Â  Â  Â  Â  Â  padding: 15px; border-radius: 12px;
Â  Â  Â  Â  Â  Â  border: 2px solid var(--secondary-glow); margin-top: 15px;
Â  Â  Â  Â  Â  Â  font-size: 1.0em; text-align: left;
Â  Â  Â  Â  Â  Â  box-shadow: 0 0 15px rgba(0, 234, 255, 0.5);
Â  Â  Â  Â  }
Â  Â  Â  Â  #infoPanel h4 { color: var(--secondary-glow); margin: 0 0 5px 0; font-size: 1.2em; }
Â  Â  Â  Â  #currentRacersList { list-style: none; padding: 0; margin: 0; display: flex; flex-wrap: wrap; gap: 10px; }
Â  Â  Â  Â  #currentRacersList li {Â 
Â  Â  Â  Â  Â  Â  background: rgba(0, 234, 255, 0.1); padding: 5px 10px; border-radius: 5px;
Â  Â  Â  Â  Â  Â  border: 1px solid var(--secondary-glow); font-size: 0.9em;
Â  Â  Â  Â  }
Â  Â  Â  Â  .eliminated-racer { color: var(--neon-red); text-decoration: line-through; opacity: 0.7; }
Â  Â  Â  Â  .eliminated-racer:before { content: "ğŸ’€"; margin-right: 5px; }
Â  Â  Â  Â  #winnerOverlay{
Â  Â  Â  Â  Â  Â  position:fixed; top:0; left:0; width:100%; height:100%;
Â  Â  Â  Â  Â  Â  background-color: rgba(0,0,0,0.95); color:var(--primary-glow);
Â  Â  Â  Â  Â  Â  font-family: 'Orbitron', sans-serif; font-size: 4.5em;
Â  Â  Â  Â  Â  Â  display:none; align-items:center; justify-content:center; flex-direction:column;
Â  Â  Â  Â  Â  Â  text-shadow: 0 0 25px var(--primary-glow); z-index:2000;
Â  Â  Â  Â  }
Â  Â  Â  Â  #winnerName{
Â  Â  Â  Â  Â  Â  color: var(--secondary-glow); font-size:1.5em; margin-top:20px;
Â  Â  Â  Â  Â  Â  text-transform:uppercase; text-shadow: 0 0 15px var(--secondary-glow), 0 0 40px var(--secondary-glow);
Â  Â  Â  Â  }
Â  Â  Â  Â  #attackStatus {
Â  Â  Â  Â  Â  Â  font-size: 1.8em;
Â  Â  Â  Â  Â  Â  color: var(--neon-red);
Â  Â  Â  Â  Â  Â  text-shadow: 0 0 10px var(--neon-red);
Â  Â  Â  Â  Â  Â  margin-top: 5px;
Â  Â  Â  Â  }
Â  Â  </style>
</head>
<body>
Â  Â  <audio id="explosionSound" src="https://www.soundboard.com/media/259837"></audio>

Â  Â  <div id="titleContainer">
Â  Â  Â  Â  <img id="logo" src="https://60fb7b08eaf293096e8c.cdn6.editmysite.com/uploads/b/60fb7b08eaf293096e8cb3f63df9e65735b8a1ee75f6d23d21eaed2115dfa2e6/IMG_7388_1701827680.jpeg?width=2400&optimize=medium" alt="Gladiator Collectibles Logo" style="filter: hue-rotate(180deg);">
Â  Â  Â  Â  <h1>POKÃ‰MON CAPTURE CHAOS</h1>
Â  Â  </div>
Â  Â  <div id="frontPage">
Â  Â  Â  Â  <h2>Last PokÃ©mon Standing Setup</h2>
Â  Â  Â  Â  <div class="setup-grid">
Â  Â  Â  Â  Â  Â  <div class="input-card" style="grid-column: span 2;">
Â  Â  Â  Â  Â  Â  Â  Â  <label for="racerNames">Racer Names (one per line, max 10):</label>
Â  Â  Â  Â  Â  Â  Â  Â  <textarea id="racerNames" rows="5" placeholder="Ash\nMisty\nBrock\nGary\nLance\nSabrina\nGiovanni\nBlue"></textarea>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div class="action-buttons">
            Â  Â  Â  Â  Â  Â  <a href="elimination.html" class="game-button prepare">
Â  Â  Â  Â  Â  Â  Â  Â  GLADIATOR ELIMINATION
Â  Â  Â  Â  Â  Â  </a>
Â  Â  Â  Â  Â  Â  <button id="submitNamesButton" class="game-button">SUBMIT NAMES & ASSIGN TYPES</button>
Â  Â  Â  Â  Â  Â  <button id="setupStartButton" class="game-button">START GAME</button>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div id="status">Systems nominal. Enter names, submit, and click 'START GAME' to begin.</div>
Â  Â  </div>
Â  Â Â 
Â  Â  <div id="gameView">
Â  Â  Â  Â  <canvas id="gameCanvas" width="500" height="500"></canvas>
Â  Â  Â  Â  <div id="attackStatus"></div>
Â  Â  Â  Â  <div id="infoPanel">
Â  Â  Â  Â  Â  Â  <h4>Round Status: <span id="roundDisplay">N/A</span> | Elimination Mode: **Single Target**</h4>
Â  Â  Â  Â  Â  Â  <p>Attack Type: <strong id="attackTypeDisplay">Neutral</strong> (Pattern: <span id="attackPatternDisplay">None</span>)</p>
Â  Â  Â  Â  Â  Â  <p>Active Players: <ul id="currentRacersList"></ul></p>
Â  Â  Â  Â  Â  Â  <p style="margin-top: 10px;">Type Advantage Key: <span style="color: yellow; text-shadow: 0 0 5px yellow;">â­ Immune</span> / <span style="color: lime; text-shadow: 0 0 5px lime;">âœ¨ Evasion</span></p>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <div id="gameControls">
Â  Â  Â  Â  Â  Â  <button id="shuffleButton" class="game-button">SHUFFLE POKEMON</button>
Â  Â  Â  Â  Â  Â  <button id="startGameButton" class="game-button prepare">START CAPTURE CHAOS</button>
Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â  <div id="winnerOverlay">
Â  Â  Â  Â  VICTORIOUS!
Â  Â  Â  Â  <span id="winnerName"></span>
Â  Â  Â  Â  <button onclick="resetGame()" class="game-button" style="margin-top: 40px;">NEW GAME</button>
Â  Â  </div>
Â  Â  <script>
Â  Â  Â  Â  const canvas = document.getElementById('gameCanvas');
Â  Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â  Â  const setupControls = document.getElementById('frontPage');
Â  Â  Â  Â  const gameView = document.getElementById('gameView');
Â  Â  Â  Â  const submitNamesButton = document.getElementById('submitNamesButton');
Â  Â  Â  Â  const setupStartButton = document.getElementById('setupStartButton');
Â  Â  Â  Â  const startGameButton = document.getElementById('startGameButton');
Â  Â  Â  Â  const shuffleButton = document.getElementById('shuffleButton');
Â  Â  Â  Â  const statusDisplay = document.getElementById('status');
Â  Â  Â  Â  const titleContainer = document.getElementById('titleContainer');
Â  Â  Â  Â  const roundDisplay = document.getElementById('roundDisplay');
Â  Â  Â  Â  const attackTypeDisplay = document.getElementById('attackTypeDisplay');
Â  Â  Â  Â  const attackPatternDisplay = document.getElementById('attackPatternDisplay');
Â  Â  Â  Â  const currentRacersList = document.getElementById('currentRacersList');
Â  Â  Â  Â  const winnerOverlay = document.getElementById('winnerOverlay');
Â  Â  Â  Â  const winnerNameDisplay = document.getElementById('winnerName');
Â  Â  Â  Â  const attackStatus = document.getElementById('attackStatus');
Â  Â  Â  Â  const explosionSound = document.getElementById('explosionSound');
Â  Â  Â  Â Â 
Â  Â  Â  Â  const GRID_SIZE = 10;
Â  Â  Â  Â  const TILE_SIZE = canvas.width / GRID_SIZE;
Â  Â  Â  Â  const POKEMON_IMAGE_SIZE = TILE_SIZE * 0.9;
Â  Â  Â  Â  const GAME_STATES = { SETUP: 'SETUP', PREPARING: 'PREPARING', PLAYING: 'PLAYING', FINISHED: 'FINISHED' };
Â  Â  Â  Â  let gameState = GAME_STATES.SETUP;
Â  Â  Â  Â  let racers = [];
Â  Â  Â  Â  let roundNumber = 0;
Â  Â  Â  Â  let gameLoopInterval;
Â  Â  Â  Â  let roundPhase = 0; // 0: Move (3000ms), 1: Warning/Attack (1500ms), 2: Resolution (500ms)
Â  Â  Â  Â  const PHASE_TIMINGS = [3000, 1500, 1000]; // Increased resolution time for visual bomb effect

Â  Â  Â  Â  // --- Assets ---
Â  Â  Â  Â  const POKEBALL_URL = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/items/poke-ball.png';
Â  Â  Â  Â  const POKEBALL_IMAGE = new Image();
Â  Â  Â  Â  POKEBALL_IMAGE.src = POKEBALL_URL;

Â  Â  Â  Â  // Custom Bomb Sprite (Use a yellow circle for explosion effect)
Â  Â  Â  Â  const BOMB_COLOR = 'rgba(255, 255, 0, 1)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  const POKEMON_TYPES = ['Grass', 'Fire', 'Water', 'Electric', 'Ground', 'Fighting', 'Flying', 'Psychic'];
Â  Â  Â  Â Â 
Â  Â  Â  Â  // --- Attack Pattern definitions ---
Â  Â  Â  Â  const ATTACK_PATTERNS = {
Â  Â  Â  Â  Â  Â  'Earthquake': { type: 'Ground', name: 'Earthquake' },
Â  Â  Â  Â  Â  Â  'Thunder Wave': { type: 'Electric', name: 'Thunder Wave' },
Â  Â  Â  Â  Â  Â  'Hydro Pump': { type: 'Water', name: 'Hydro Pump' },
Â  Â  Â  Â  Â  Â  'Fire Blast': { type: 'Fire', name: 'Fire Blast' },
Â  Â  Â  Â  Â  Â  'Psychic Surge': { type: 'Psychic', name: 'Psychic Surge' }
Â  Â  Â  Â  };

Â  Â  Â  Â  const pokemonData = [];
Â  Â  Â  Â  for (let id = 1; id <= 151; id++) {
Â  Â  Â  Â  Â  Â  pokemonData.push({
Â  Â  Â  Â  Â  Â  Â  Â  id, name: `Poke ${id}`,
Â  Â  Â  Â  Â  Â  Â  Â  imageGif: `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/${id}.gif`,
Â  Â  Â  Â  Â  Â  Â  Â  sprite: null
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }
Â  Â  Â  Â  pokemonData.forEach(p => {
Â  Â  Â  Â  Â  Â  const img = new Image();
Â  Â  Â  Â  Â  Â  img.onload = () => { p.sprite = img; };
Â  Â  Â  Â  Â  Â  img.src = p.imageGif;
Â  Â  Â  Â  });

Â  Â  Â  Â  // --- Core Game Logic ---
Â  Â  Â  Â  let currentAttack = { type: 'Neutral', name: 'Aura Scan', targetRacer: null, dodgeEffect: false };
Â  Â  Â  Â  let availableAttacks = Object.keys(ATTACK_PATTERNS);

Â  Â  Â  Â  function playExplosion() {
Â  Â  Â  Â  Â  Â  if (explosionSound.readyState >= 2) {
Â  Â  Â  Â  Â  Â  Â  Â  explosionSound.currentTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  explosionSound.play().catch(e => console.error("Audio playback failed:", e));
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function drawGame() {
Â  Â  Â  Â  Â  Â  ctx.clearRect(0, 0, canvas.width, canvas.height);

Â  Â  Â  Â  Â  Â  // 1. Draw Grid AuraÂ 
Â  Â  Â  Â  Â  Â  ctx.fillStyle = 'var(--grid-color-dark)';
Â  Â  Â  Â  Â  Â  ctx.fillRect(0, 0, canvas.width, canvas.height);

Â  Â  Â  Â  Â  Â  // 2. Draw Grid Lines (Neon Effect)
Â  Â  Â  Â  Â  Â  ctx.strokeStyle = 'var(--secondary-glow)';
Â  Â  Â  Â  Â  Â  ctx.shadowColor = 'var(--secondary-glow)';
Â  Â  Â  Â  Â  Â  ctx.shadowBlur = 8;
Â  Â  Â  Â  Â  Â  ctx.lineWidth = 1;
Â  Â  Â  Â  Â  Â  for (let i = 0; i <= GRID_SIZE; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath(); ctx.moveTo(i * TILE_SIZE, 0); ctx.lineTo(i * TILE_SIZE, canvas.height); ctx.stroke();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath(); ctx.moveTo(0, i * TILE_SIZE); ctx.lineTo(canvas.width, i * TILE_SIZE); ctx.stroke();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  ctx.shadowBlur = 0;Â 

Â  Â  Â  Â  Â  Â  // 3. Draw Target Tile Flashing (Phase 1/2)
Â  Â  Â  Â  Â  Â  if (currentAttack.targetRacer && currentAttack.targetRacer.active && (roundPhase === 1 || roundPhase === 2)) {
Â  Â  Â  Â  Â  Â  Â  Â  const r = currentAttack.targetRacer;
Â  Â  Â  Â  Â  Â  Â  Â  const flash = Math.sin(Date.now() / 50) * 0.5 + 0.5; // High speed flash
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = `rgba(255, 0, 0, ${0.4 * flash})`; // Red warning
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillRect(r.targetX * TILE_SIZE, r.targetY * TILE_SIZE, TILE_SIZE, TILE_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Draw target crosshair
Â  Â  Â  Â  Â  Â  Â  Â  ctx.strokeStyle = `rgba(255, 255, 0, ${0.8 * flash})`;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineWidth = 4;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.moveTo(r.targetX * TILE_SIZE, r.targetY * TILE_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineTo((r.targetX + 1) * TILE_SIZE, (r.targetY + 1) * TILE_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.moveTo((r.targetX + 1) * TILE_SIZE, r.targetY * TILE_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineTo(r.targetX * TILE_SIZE, (r.targetY + 1) * TILE_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  Â  Â  }


Â  Â  Â  Â  Â  Â  // 4. Draw Racers
Â  Â  Â  Â  Â  Â  racers.filter(r => r.active).forEach(r => {
Â  Â  Â  Â  Â  Â  Â  Â  const x = r.x * TILE_SIZE + TILE_SIZE / 2;
Â  Â  Â  Â  Â  Â  Â  Â  const y = r.y * TILE_SIZE + TILE_SIZE / 2;
Â  Â  Â  Â  Â  Â  Â  Â  const nameText = `${r.name} (${r.data.type})`;

Â  Â  Â  Â  Â  Â  Â  Â  ctx.save();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.translate(x, y);

Â  Â  Â  Â  Â  Â  Â  Â  // Draw immunity/Evasion glow
Â  Â  Â  Â  Â  Â  Â  Â  if (r.isSafe) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.arc(0, 0, TILE_SIZE * 0.4, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = r.isSafe === 'IMMUNE' ? 'rgba(255,255,0,0.3)' : 'rgba(0,255,0,0.3)';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.strokeStyle = r.isSafe === 'IMMUNE' ? 'yellow' : 'lime';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Draw Sprite
Â  Â  Â  Â  Â  Â  Â  Â  if (r.data.sprite && r.data.sprite.complete) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.drawImage(r.data.sprite, -POKEMON_IMAGE_SIZE / 2, -POKEMON_IMAGE_SIZE / 2, POKEMON_IMAGE_SIZE, POKEMON_IMAGE_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // Draw Name Tag
Â  Â  Â  Â  Â  Â  Â  Â  ctx.font = `bold ${TILE_SIZE * 0.25}px "Bebas Neue", sans-serif`;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.textAlign = 'center';
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = 'white';
Â  Â  Â  Â  Â  Â  Â  Â  ctx.strokeStyle = 'black';
Â  Â  Â  Â  Â  Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  ctx.strokeText(nameText, 0, -TILE_SIZE / 2);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillText(nameText, 0, -TILE_SIZE / 2);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  ctx.restore();
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  // 5. Draw Capture Animation (Explosion Effect)
Â  Â  Â  Â  Â  Â  racers.filter(r => r.captureAnimation).forEach(r => {
Â  Â  Â  Â  Â  Â  Â  Â  const x = r.x * TILE_SIZE + TILE_SIZE / 2;
Â  Â  Â  Â  Â  Â  Â  Â  const y = r.y * TILE_SIZE + TILE_SIZE / 2;
Â  Â  Â  Â  Â  Â  Â  Â  const animationTime = Date.now() - r.captureStartTime;
Â  Â  Â  Â  Â  Â  Â  Â  const duration = PHASE_TIMINGS[2];
Â  Â  Â  Â  Â  Â  Â  Â  const progress = animationTime / duration;

Â  Â  Â  Â  Â  Â  Â  Â  ctx.save();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.translate(x, y);

Â  Â  Â  Â  Â  Â  Â  Â  if (progress < 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Draw PokÃ© Ball slamming down
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const ballSize = POKEMON_IMAGE_SIZE * 1.5;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const scale = Math.min(1.0, progress * 3);Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.drawImage(POKEBALL_IMAGE, -ballSize * scale / 2, -ballSize * scale / 2, ballSize * scale, ballSize * scale);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Draw Explosion (Yellow Expanding circle)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.arc(0, 0, POKEMON_IMAGE_SIZE * progress * 2, 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = BOMB_COLOR;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.globalAlpha = 0.9 * (1 - progress); // Fade out quickly
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fill();

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Sucking effect (black circle)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.arc(0, 0, POKEMON_IMAGE_SIZE * (1.2 - progress), 0, Math.PI * 2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = 'rgba(0,0,0,0.8)';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.globalAlpha = 0.5 * (1 - progress);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  ctx.restore();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.globalAlpha = 1.0;
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- Phase Management ---

Â  Â  Â  Â  function startRound() {
Â  Â  Â  Â  Â  Â  const activeRacers = racers.filter(r => r.active);
Â  Â  Â  Â  Â  Â  if (activeRacers.length <= 1) {
Â  Â  Â  Â  Â  Â  Â  Â  endGame(activeRacers[0]);
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  roundNumber++;
Â  Â  Â  Â  Â  Â  roundPhase = 0;
Â  Â  Â  Â  Â  Â  activeRacers.forEach(r => {
Â  Â  Â  Â  Â  Â  Â  Â  r.targetX = r.x; r.targetY = r.y;Â 
Â  Â  Â  Â  Â  Â  Â  Â  r.isSafe = null;
Â  Â  Â  Â  Â  Â  Â  Â  r.captureAnimation = false;
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  updateRacerListDisplay();
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // 1. Select Attack Type/Name
Â  Â  Â  Â  Â  Â  const attackName = availableAttacks[Math.floor(Math.random() * availableAttacks.length)];
Â  Â  Â  Â  Â  Â  const attackConfig = ATTACK_PATTERNS[attackName];

Â  Â  Â  Â  Â  Â  currentAttack.name = attackName;
Â  Â  Â  Â  Â  Â  currentAttack.type = attackConfig.type;
Â  Â  Â  Â  Â  Â  currentAttack.dodgeEffect = (currentAttack.type === 'Water' || currentAttack.type === 'Fire');
Â  Â  Â  Â  Â  Â  currentAttack.targetRacer = null;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // 2. Select Single Target
Â  Â  Â  Â  Â  Â  currentAttack.targetRacer = activeRacers[Math.floor(Math.random() * activeRacers.length)];

Â  Â  Â  Â  Â  Â  updateGameInfo();
Â  Â  Â  Â  Â  Â  attackStatus.textContent = '';
Â  Â  Â  Â  Â  Â  statusDisplay.textContent = `ROUND ${roundNumber} - MOVE PHASE: ${PHASE_TIMINGS[0] / 1000} seconds to dodge!`;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  setTimeout(attackPhase, PHASE_TIMINGS[0]);
Â  Â  Â  Â  Â  Â  drawGame();
Â  Â  Â  Â  }

Â  Â  Â  Â  function attackPhase() {
Â  Â  Â  Â  Â  Â  roundPhase = 1;
Â  Â  Â  Â  Â  Â  const targetName = currentAttack.targetRacer ? currentAttack.targetRacer.name : 'NO TARGET';
Â  Â  Â  Â  Â  Â  attackStatus.textContent = `!! ${targetName} MARKED FOR CAPTURE !!`;
Â  Â  Â  Â  Â  Â  statusDisplay.textContent = `ROUND ${roundNumber} - ATTACK WARNING: ${currentAttack.name} Incoming!`;
Â  Â  Â  Â  Â  Â  updateGameInfo();
Â  Â  Â  Â  Â  Â  drawGame();
Â  Â  Â  Â  Â  Â  setTimeout(resolutionPhase, PHASE_TIMINGS[1]);
Â  Â  Â  Â  }

Â  Â  Â  Â  function resolutionPhase() {
Â  Â  Â  Â  Â  Â  roundPhase = 2;
Â  Â  Â  Â  Â  Â  attackStatus.textContent = '';
Â  Â  Â  Â  Â  Â  statusDisplay.textContent = `ROUND ${roundNumber} - RESOLUTION: Did ${currentAttack.targetRacer.name} escape?`;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const r = currentAttack.targetRacer;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if (r.active) {
Â  Â  Â  Â  Â  Â  Â  Â  // Finalize movement before checking capture
Â  Â  Â  Â  Â  Â  Â  Â  r.x = r.targetX;Â 
Â  Â  Â  Â  Â  Â  Â  Â  r.y = r.targetY;

Â  Â  Â  Â  Â  Â  Â  Â  let captured = true;
Â  Â  Â  Â  Â  Â  Â  Â  let reason = currentAttack.type;

Â  Â  Â  Â  Â  Â  Â  Â  // 1. Check for Immunity
Â  Â  Â  Â  Â  Â  Â  Â  const type = r.data.type;
Â  Â  Â  Â  Â  Â  Â  Â  if ((currentAttack.type === 'Ground' && (type === 'Flying' || type === 'Grass')) ||Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  (currentAttack.type === 'Electric' && type === 'Ground')) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r.isSafe = 'IMMUNE';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  captured = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  reason = `IMMUNE (${type})`;
Â  Â  Â  Â  Â  Â  Â  Â  }Â 
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // 2. Check for Evasion
Â  Â  Â  Â  Â  Â  Â  Â  else if (currentAttack.dodgeEffect && (type === 'Water' || type === 'Fire')) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (Math.random() < 0.5) {Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  captured = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r.isSafe = 'EVADED';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  reason = `EVADED (${type})`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  reason = `CAUGHT (Failed Evasion)`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  reason = `CAUGHT (Hit by ${currentAttack.type})`;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // 3. Final Elimination
Â  Â  Â  Â  Â  Â  Â  Â  if (captured) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r.captureAnimation = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r.captureStartTime = Date.now();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r.eliminationReason = reason;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  playExplosion();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Set elimination to happen after the animation (PHASE_TIMINGS[2])
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r.active = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusDisplay.textContent = `ğŸ’¥ ${r.name} was CAPTURED!`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  updateRacerListDisplay();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(startRound, 200); // Quick transition to next round
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, PHASE_TIMINGS[2]);Â 
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusDisplay.textContent = `âœ… ${r.name} survived! Reason: ${reason}.`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(startRound, 200);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  // Target was eliminated in a previous round but was still selected (shouldn't happen with filter)
Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(startRound, 50);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function endGame(winner) {
Â  Â  Â  Â  Â  Â  gameState = GAME_STATES.FINISHED;
Â  Â  Â  Â  Â  Â  winnerNameDisplay.textContent = winner ? `${winner.name} WINS!` : "NO WINNER LEFT!";
Â  Â  Â  Â  Â  Â  winnerOverlay.style.display = 'flex';
Â  Â  Â  Â  Â  Â  statusDisplay.textContent = `GAME OVER! ${winner ? winner.name : 'Everyone'} survived ${roundNumber} rounds.`;
Â  Â  Â  Â  Â  Â  titleContainer.classList.remove('game-active');
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- Utility Functions ---

Â  Â  Â  Â  function updateRacerListDisplay() {
Â  Â  Â  Â  Â  Â  currentRacersList.innerHTML = racers.map(r => {
Â  Â  Â  Â  Â  Â  Â  Â  const isEliminated = !r.active;
Â  Â  Â  Â  Â  Â  Â  Â  let display = `${r.name} (${r.data.type})`;
Â  Â  Â  Â  Â  Â  Â  Â  if (isEliminated) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  display += ` - ${r.eliminationReason || 'Capture'}`;
Â  Â  Â  Â  Â  Â  Â  Â  } else if (currentAttack.targetRacer === r && roundPhase !== 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â display = `ğŸ”¥ ${display} ğŸ”¥`;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  return `<li class="${isEliminated ? 'eliminated-racer' : ''}">${display}</li>`;
Â  Â  Â  Â  Â  Â  }).join('');
Â  Â  Â  Â  }

Â  Â  Â  Â  function updateGameInfo() {
Â  Â  Â  Â  Â  Â  roundDisplay.textContent = `#${roundNumber}`;
Â  Â  Â  Â  Â  Â  attackTypeDisplay.textContent = currentAttack.type;
Â  Â  Â  Â  Â  Â  attackPatternDisplay.textContent = currentAttack.name;
Â  Â  Â  Â  }

Â  Â  Â  Â  function submitNames() {
Â  Â  Â  Â  Â  Â  initRacers(true);
Â  Â  Â  Â  Â  Â  if (racers.length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  statusDisplay.textContent = 'Please enter at least one racer name.';
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  updateRacerListDisplay();
Â  Â  Â  Â  Â  Â  statusDisplay.textContent = `Submitted ${racers.length} PokÃ©mon. Ready to start!`;
Â  Â  Â  Â  Â  Â  drawGame();
Â  Â  Â  Â  }

Â  Â  Â  Â  function prepareGame() {
Â  Â  Â  Â  Â  Â  if (racers.length < 2) {
Â  Â  Â  Â  Â  Â  Â  Â  statusDisplay.textContent = 'Need at least 2 racers to start the chaos!';
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  gameState = GAME_STATES.PREPARING;
Â  Â  Â  Â  Â  Â  setupControls.style.display = 'none';Â 
Â  Â  Â  Â  Â  Â  gameView.style.display = 'block';Â 
Â  Â  Â  Â  Â  Â  titleContainer.classList.add('game-active');
Â  Â  Â  Â  Â  Â  statusDisplay.textContent = 'PREPARE: Shuffle Types, then click START CAPTURE CHAOS.';
Â  Â  Â  Â  Â  Â  drawGame();
Â  Â  Â  Â  }

Â  Â  Â  Â  function startGame() {
Â  Â  Â  Â  Â  Â  gameState = GAME_STATES.PLAYING;
Â  Â  Â  Â  Â  Â  setupControls.style.display = 'none';Â 
Â  Â  Â  Â  Â  Â  startGameButton.style.display = 'none';
Â  Â  Â  Â  Â  Â  shuffleButton.style.display = 'none';
Â  Â  Â  Â  Â  Â  startRound();
Â  Â  Â  Â  }

Â  Â  Â  Â  function resetGame() {
Â  Â  Â  Â  Â  Â  gameState = GAME_STATES.SETUP;
Â  Â  Â  Â  Â  Â  roundNumber = 0;
Â  Â  Â  Â  Â  Â  currentAttack = { type: 'Neutral', name: 'Aura Scan', targetRacer: null, dodgeEffect: false };
Â  Â  Â  Â  Â  Â  winnerOverlay.style.display = 'none';
Â  Â  Â  Â  Â  Â  setupControls.style.display = 'block';
Â  Â  Â  Â  Â  Â  gameView.style.display = 'none';
Â  Â  Â  Â  Â  Â  titleContainer.classList.remove('game-active');
Â  Â  Â  Â  Â  Â  updateGameInfo();
Â  Â  Â  Â  Â  Â  currentRacersList.innerHTML = '';
Â  Â  Â  Â  Â  Â  statusDisplay.textContent = 'Systems nominal. Enter names to begin.';
Â  Â  Â  Â  Â  Â  initRacers(false);Â 
Â  Â  Â  Â  Â  Â  drawGame();
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- AI Movement Logic (Simple Random Walk) ---
Â  Â  Â  Â  function moveAI() {
Â  Â  Â  Â  Â  Â  if (gameState !== GAME_STATES.PLAYING || roundPhase !== 0) return;

Â  Â  Â  Â  Â  Â  // Update targets during the Move Phase (0) only
Â  Â  Â  Â  Â  Â  racers.filter(r => r.active).forEach(r => {
Â  Â  Â  Â  Â  Â  Â  Â  const availableMoves = [];
Â  Â  Â  Â  Â  Â  Â  Â  // Check all 9 possible moves (8 adjacent + stay put)
Â  Â  Â  Â  Â  Â  Â  Â  for (let dx = -1; dx <= 1; dx++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let dy = -1; dy <= 1; dy++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const newX = r.x + dx;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const newY = r.y + dy;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (newX >= 0 && newX < GRID_SIZE && newY >= 0 && newY < GRID_SIZE) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  availableMoves.push({ x: newX, y: newY });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  if (availableMoves.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const randomMove = availableMoves[Math.floor(Math.random() * availableMoves.length)];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r.targetX = randomMove.x;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  r.targetY = randomMove.y;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  drawGame();
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  function initRacers(fromSetup = true) {
Â  Â  Â  Â  Â  Â  racers = [];
Â  Â  Â  Â  Â  Â  const customNamesInput = document.getElementById('racerNames');
Â  Â  Â  Â  Â  Â  let customNames = customNamesInput.value.split('\n').map(name => name.trim()).filter(name => name).slice(0, 10);
Â  Â  Â  Â  Â  Â  if (customNames.length === 0 && fromSetup) return;

Â  Â  Â  Â  Â  Â  const shuffledPokemon = [...pokemonData].sort(() => 0.5 - Math.random());
Â  Â  Â  Â  Â  Â  const numRacers = Math.min(customNames.length, shuffledPokemon.length);

Â  Â  Â  Â  Â  Â  const usedTiles = new Set();
Â  Â  Â  Â  Â  Â  for (let i = 0; i < numRacers; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  let x, y, posKey;
Â  Â  Â  Â  Â  Â  Â  Â  do {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x = Math.floor(Math.random() * GRID_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y = Math.floor(Math.random() * GRID_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  posKey = `${x},${y}`;
Â  Â  Â  Â  Â  Â  Â  Â  } while (usedTiles.has(posKey));
Â  Â  Â  Â  Â  Â  Â  Â  usedTiles.add(posKey);

Â  Â  Â  Â  Â  Â  Â  Â  racers.push({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  name: customNames[i],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  data: { ...shuffledPokemon[i], type: POKEMON_TYPES[i % POKEMON_TYPES.length] },
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  active: true,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x: x,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y: y,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  targetX: x,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  targetY: y,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isSafe: null,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  captureAnimation: false,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  eliminationReason: null
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (racers.length > 0) reassignPokemons(false);Â 
Â  Â  Â  Â  }

Â  Â  Â  Â  function reassignPokemons(updateDisplay = true) {
Â  Â  Â  Â  Â  Â  if (racers.length === 0) return;
Â  Â  Â  Â  Â  Â  const shuffledPokemon = [...pokemonData].sort(() => 0.5 - Math.random());
Â  Â  Â  Â  Â  Â  const shuffledTypes = [...POKEMON_TYPES].sort(() => 0.5 - Math.random());Â 

Â  Â  Â  Â  Â  Â  racers.forEach((racer, i) => {
Â  Â  Â  Â  Â  Â  Â  Â  const newPoke = shuffledPokemon[i % shuffledPokemon.length];
Â  Â  Â  Â  Â  Â  Â  Â  const newType = shuffledTypes[i % shuffledTypes.length];
Â  Â  Â  Â  Â  Â  Â  Â  racer.data = { ...newPoke, type: newType };
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  if (updateDisplay) submitNames(false);Â 
Â  Â  Â  Â  Â  Â  drawGame();
Â  Â  Â  Â  }

Â  Â  Â  Â  // --- Event Listeners ---
Â  Â  Â  Â  submitNamesButton.addEventListener('click', submitNames);
Â  Â  Â  Â  setupStartButton.addEventListener('click', prepareGame);
Â  Â  Â  Â  startGameButton.addEventListener('click', startGame);
Â  Â  Â  Â  shuffleButton.addEventListener('click', () => reassignPokemons(true));

Â  Â  Â  Â  // Start game loop (handles AI movement)
Â  Â  Â  Â  gameLoopInterval = setInterval(moveAI, 100);
Â  Â  Â  Â  // Continuous redraw for animations (PokÃ© Ball slam, flashing grid)
Â  Â  Â  Â  setInterval(drawGame, 50);

Â  Â  Â  Â  // Initial setup
Â  Â  Â  Â  initRacers(false);Â 
Â  Â  Â  Â  drawGame();
Â  Â  </script>
</body>
</html>
