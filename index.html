<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Gladiator Collectibles Race</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@700&family=Bebas+Neue&display=swap" rel="stylesheet">
    <style>
        :root{
            --primary-glow: #e0e0e0;
            --secondary-glow: #00eaff;
            --bg-dark: #0a0a0a;
            --text-light: #f0ff00;
            --neutral-dark: #333;
            --neutral-medium: #555;
            --neutral-light: #bbb;
            --track-color-dark: #1a1a1a;
            --track-color-medium: #2a2a2a;
            --track-color-light: #3a3a3a;
            --finish-line-color-primary: #ffffff;
            --finish-line-color-secondary: #000000;
            --racer-name-color: #FFFFFF;
            --prepare-color: #ff5500;
            --surge-color: #ff0044;
            --neon-red: #ff1744;
            /* NEW DESIGN VARIABLES */
            --header-height: 80px;
            --control-panel-width: 300px;
        }
        html,body{
            height:100%;
            margin:0;
            padding:0;
            background: linear-gradient(135deg, #0d011a, var(--bg-dark), #010a14);
            color: var(--text-light);
            font-family: 'Bebas Neue', sans-serif;
            -webkit-font-smoothing:antialiased;
            -moz-osx-font-smoothing:grayscale;
            overflow: hidden; /* Prevent body scroll */
        }
        
        /* HEADER - Always visible */
        #header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: var(--header-height);
            background: rgba(10, 10, 10, 0.95);
            box-shadow: 0 4px 15px rgba(0, 234, 255, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }
        #mainLogo {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            box-shadow: 0 0 10px var(--secondary-glow);
            margin-right: 15px;
        }
        #mainTitle {
            font-family: 'Orbitron', sans-serif;
            color: var(--secondary-glow);
            text-shadow: 0 0 10px var(--secondary-glow);
            letter-spacing: 2px;
            font-size: 2.2em;
            margin: 0;
            text-transform: uppercase;
        }

        /* MAIN CONTENT AREA */
        #mainContent {
            display: flex;
            height: calc(100vh - var(--header-height));
            margin-top: var(--header-height);
        }

        /* CONTROL PANEL */
        #controlPanel {
            width: var(--control-panel-width);
            min-width: 300px;
            background: linear-gradient(180deg, rgba(10,10,10,0.9), rgba(26,26,26,0.9));
            border-right: 2px solid var(--secondary-glow);
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            position: relative;
            z-index: 100;
        }
        #controlPanel h2 {
            font-family:'Orbitron',sans-serif;
            color: var(--secondary-glow);
            text-shadow:0 0 10px var(--secondary-glow);
            margin: 0 0 15px 0;
            letter-spacing:2px;
            font-size: 1.8em;
            text-align: center;
        }
        .input-group label {
            display: block;
            margin-top: 15px;
            margin-bottom: 5px;
            color: var(--neutral-light);
            font-size: 0.9em;
            font-weight: bold;
        }
        .input-group input, .input-group textarea {
            width: 100%;
            background: var(--neutral-dark);
            color: var(--text-light);
            border: 1px solid var(--secondary-glow);
            padding: 8px;
            border-radius: 4px;
            font-size: 1em;
            box-sizing: border-box;
            resize: vertical;
            min-height: 60px;
        }
        .action-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }
        .race-button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1em;
            transition: all 0.3s;
            background: linear-gradient(45deg, var(--secondary-glow), #00aaff);
            color: #111;
            box-shadow: 0 4px 10px rgba(0,234,255,0.35);
            text-shadow: 1px 1px 0 rgba(255,255,255,0.2);
        }
        .race-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(0,234,255,0.5);
        }
        .race-button.prepare {
            background: linear-gradient(45deg, var(--neon-red), #ff4081);
            color: var(--text-light);
            box-shadow: 0 4px 10px rgba(255, 23, 68, 0.6);
        }
        .race-button:disabled { cursor: not-allowed; opacity: 0.6; transform: none; box-shadow: none; }
        
        #status {
            padding: 10px;
            background: rgba(0,234,255,0.1);
            border: 1px solid var(--secondary-glow);
            border-radius: 6px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9em;
            color: var(--primary-glow);
            text-shadow: 0 0 4px var(--primary-glow);
            margin-top: 15px;
            text-align: center;
        }

        /* RACE VIEW & CANVAS */
        #raceView {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background: radial-gradient(circle at center, #1a1a1a 0%, #0a0a0a 100%);
        }
        #raceCanvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }

        /* CORNER LOGOS (for fullscreen race view only) */
        .corner-logo {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 6px;
            box-shadow: 0 0 8px rgba(255,255,255,0.5), 0 0 15px var(--secondary-glow);
            z-index: 1500;
            opacity: 0.8;
            display: none; /* Hidden by default */
        }
        #raceView.fullscreen .corner-logo {
            display: block; /* Show only when raceView is fullscreen */
        }
        #logo-tl { top: 15px; left: 15px; }
        #logo-tr { top: 15px; right: 15px; }
        #logo-bl { bottom: 15px; left: 15px; }
        #logo-br { bottom: 15px; right: 15px; }

        /* FULLSCREEN RACE OVERLAY */
        #raceView.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            margin-top: 0; /* Override margin from body */
            z-index: 1900;
        }
        #raceView.fullscreen #raceControls {
            position: fixed; /* Keep controls visible over canvas */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2000;
        }
        .controls.hidden { display: none; }
        
        /* LEADERBOARD & WINNER (Kept original styling) */
        #leaderboard { display: none; }
        #leaderboard.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #0d011a, var(--bg-dark), #010a14);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
        }
        .leaderboard-content {
            width: 100%;
            max-width: 700px;
            text-align: center;
        }
        #postRaceControls { margin-top: 40px; }
        #winnerOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.95);
            color: var(--primary-glow);
            font-family: 'Orbitron', sans-serif;
            font-size: 4.5em;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            text-shadow: 0 0 25px var(--primary-glow);
            z-index: 4000;
        }
        #winnerName { color: var(--secondary-glow); font-size: 1.5em; margin-top: 20px; text-transform: uppercase; text-shadow: 0 0 15px var(--secondary-glow); }
        
        /* MOBILE / RESPONSIVE STYLES */
        @media (max-width: 900px) {
            #mainContent {
                flex-direction: column;
                height: auto;
            }
            #controlPanel {
                width: 100%;
                max-height: 40vh;
                border-right: none;
                border-bottom: 2px solid var(--secondary-glow);
            }
            #raceView {
                height: 60vh;
            }
            #raceView.fullscreen {
                width: 100vw;
                height: 100vh;
            }
        }
        @media (max-width: 500px) {
            #mainTitle { font-size: 1.6em; }
            #header { height: 60px; }
            #mainContent { margin-top: 60px; }
            .race-button { padding: 10px 15px; font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <div id="header">
        <img id="mainLogo" src="https://60fb7b08eaf293096e8c.cdn6.editmysite.com/uploads/b/60fb7b08eaf293096e8cb3f63df9e65735b8a1ee75f6d23d21eaed2115dfa2e6/IMG_7388_1701827680.jpeg?width=2400&optimize=medium" alt="Gladiator Collectibles Logo">
        <h1 id="mainTitle">GLADIATOR COLLECTIBLES</h1>
    </div>

    <div id="mainContent">
        <div id="controlPanel">
            <h2>Race Setup</h2>
            <div class="input-group">
                <label for="raceTimeSeconds">Target Race Time (seconds):</label>
                <input type="number" id="raceTimeSeconds" min="10" max="300" value="69">
            </div>
            <div class="input-group">
                <label for="raceLengthDisplay">Target Finish Line (px):</label>
                <input type="number" id="raceLengthDisplay" value="0" readonly title="The calculated finish line distance.">
            </div>
            <div class="input-group">
                <label for="racerNames">Racer Names (one per line):</label>
                <textarea id="racerNames" rows="5" placeholder="Ash\nMisty\nBrock\nGary\nLance"></textarea>
            </div>
            <div class="action-buttons">
                <button id="submitNamesButton" class="race-button">SUBMIT NAMES</button>
                <button id="setupStartButton" class="race-button">START RACE</button>
            </div>
            <div id="status">Systems nominal. Enter names (one per line), submit, and click 'START RACE' to begin.</div>
            
            </div>

        <div id="raceView">
            <img class="corner-logo" id="logo-tl" src="https://60fb7b08eaf293096e8c.cdn6.editmysite.com/uploads/b/60fb7b08eaf293096e8cb3f63df9e65735b8a1ee75f6d23d21eaed2115dfa2e6/IMG_7388_1701827680.jpeg?width=2400&optimize=medium" alt="Gladiator Collectibles Logo Top Left">
            <img class="corner-logo" id="logo-tr" src="https://60fb7b08eaf293096e8c.cdn6.editmysite.com/uploads/b/60fb7b08eaf293096e8cb3f63df9e65735b8a1ee75f6d23d21eaed2115dfa2e6/IMG_7388_1701827680.jpeg?width=2400&optimize=medium" alt="Gladiator Collectibles Logo Top Right">
            <img class="corner-logo" id="logo-bl" src="https://60fb7b08eaf293096e8c.cdn6.editmysite.com/uploads/b/60fb7b08eaf293096e8cb3f63df9e65735b8a1ee75f6d23d21eaed2115dfa2e6/IMG_7388_1701827680.jpeg?width=2400&optimize=medium" alt="Gladiator Collectibles Logo Bottom Left">
            <img class="corner-logo" id="logo-br" src="https://60fb7b08eaf293096e8c.cdn6.editmysite.com/uploads/b/60fb7b08eaf293096e8cb3f63df9e65735b8a1ee75f6d23d21eaed2115dfa2e6/IMG_7388_1701827680.jpeg?width=2400&optimize=medium" alt="Gladiator Collectibles Logo Bottom Right">

            <div id="raceControls" class="controls">
                <button id="shuffleButton" class="race-button">SHUFFLE POKEMON</button>
                <button id="raceScreenStartButton" class="race-button prepare">START RACE (GO!)</button>
            </div>
            <canvas id="raceCanvas"></canvas>
        </div>
    </div>
    
    <div id="leaderboard">
Â  Â  Â  Â  <div class="leaderboard-content">
Â  Â  Â  Â  Â  Â  <div id="leaderboardTitle"></div>
Â  Â  Â  Â  Â  Â  <div id="leaderboardList"></div>
Â  Â  Â  Â  Â  Â  <div id="postRaceControls" class="controls" style="display:none;">
Â  Â  Â  Â  Â  Â  Â  Â  <button onclick="resetRace()" class="race-button" style="background: linear-gradient(45deg, #ff9900, #ff5500);">RETURN TO SETUP</button>
Â  Â  Â  Â  Â  Â  </div>
Â  Â  Â  Â  </div>
Â  Â  </div>
Â  Â  <div id="winnerOverlay">
Â  Â  Â  Â  VICTORY!
Â  Â  Â  Â  <span id="winnerName"></span>
Â  Â  </div>
    
    <script>
Â  Â  Â  Â  const canvas = document.getElementById('raceCanvas');
Â  Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â  Â  const setupControls = document.getElementById('controlPanel');
Â  Â  Â  Â  const raceView = document.getElementById('raceView');
Â  Â  Â  Â  const raceControls = document.getElementById('raceControls');
Â  Â  Â  Â  const postRaceControls = document.getElementById('postRaceControls');
Â  Â  Â  Â  const winnerOverlay = document.getElementById('winnerOverlay');
Â  Â  Â  Â  const leaderboard = document.getElementById('leaderboard');
Â  Â  Â  Â  const submitNamesButton = document.getElementById('submitNamesButton');
Â  Â  Â  Â  const setupStartButton = document.getElementById('setupStartButton');
Â  Â  Â  Â  const raceScreenStartButton = document.getElementById('raceScreenStartButton');
Â  Â  Â  Â  const shuffleButton = document.getElementById('shuffleButton');
Â  Â  Â  Â  const statusDisplay = document.getElementById('status');
Â  Â  Â  Â  
        // Renamed 'frontPage' to 'controlPanel' for context
        const controlPanel = document.getElementById('controlPanel');
        
Â  Â  Â  Â  let CANVAS_VIEWPORT_WIDTH, CANVAS_VIEWPORT_HEIGHT;
Â  Â  Â  Â  // MODIFIED: Increased anchor to 40% for better visual centering
Â  Â  Â  Â  const FIXED_RACER_X_ANCHOR_PCT = 0.40;
Â  Â  Â  Â 
Â  Â  Â  Â  let cameraAnchorX;
Â  Â  Â  Â  let trackOffset = 0;
Â  Â  Â  Â  let lastFrameTime = 0;
Â  Â  Â  Â  const POKEMON_IMAGE_SIZE = 88;
Â  Â  Â  Â  const NAME_TAG_FONT_SIZE = 20;
Â  Â  Â  Â  const NAME_TAG_PADDING = 8;
Â  Â  Â  Â  const GRASS_AREA_HEIGHT = 100;
Â  Â  Â  Â  let laneHeight = 100;
Â  Â  Â  Â  const START_LINE_X = 50;
Â  Â  Â  Â 
Â  Â  Â  Â  const BASE_SPEED_PER_SECOND = 80 * 1.25;
Â  Â  Â  Â  const BASE_MOMENTUM_FACTOR = 0.95;
Â  Â  Â  Â  const SURGE_MULTIPLIER = 1.6;
Â  Â  Â  Â  const DEBUFF_MULTIPLIER = 0.6;
Â  Â  Â  Â 
Â  Â  Â  Â  const RUBBER_BAND_FACTOR = 0.00;
Â  Â  Â  Â  const SHORT_BOOST_MULTIPLIER = 1.7;
Â  Â  Â  Â  const SHORT_DEBUFF_MULTIPLIER = 0.4;
Â  Â  Â  Â  const SHORT_BOOST_INTERVAL = 800;
Â  Â  Â  Â  const SHORT_DEBUFF_INTERVAL = 800;
Â  Â  Â  Â  const LEAD_SLOWDOWN_CHANCE = 0.3;
Â  Â  Â  Â 
Â  Â  Â  Â  const VOLATILITY_SWING = 0.3;
Â  Â  Â  Â 
Â  Â  Â  Â  const CAMERA_SMOOTHING_FACTOR = 0.1;
Â  Â  Â  Â  let lastBoostTime = 0;
Â  Â  Â  Â  let lastDebuffTime = 0;
Â  Â  Â  Â  let activeShortBooster = null;
Â  Â  Â  Â  let activeShortDebuffer = null;
Â  Â  Â  Â  let shortBoostEndTime = 0;
Â  Â  Â  Â  let shortDebuffEndTime = 0;
Â  Â  Â  Â  const STAMINA_COST_SURGE = 35;
Â  Â  Â  Â  const STAMINA_REGEN_RATE = 2.5;
Â  Â  Â  Â  // POSITIONAL ALGORITHM CONSTANTS
Â  Â  Â  Â  const LEADER_DEBUFF_DURATION = 2500;
Â  Â  Â  Â  const LEADER_DEBUFF_MULTIPLIER = 0.3;
Â  Â  Â  Â  const LEADER_DEBUFF_COOLDOWN = 2000;
Â  Â  Â  Â  const LAST_BOOST_DURATION = 3500;
Â  Â  Â  Â  const LAST_BOOST_MULTIPLIER = 2.2;
Â  Â  Â  Â  const LAST_BOOST_COOLDOWN = 1000;
Â  Â  Â  Â 
Â  Â  Â  Â  let TARGET_RACE_TIME_SECONDS = 60;
Â  Â  Â  Â  let racers = [];
Â  Â  Â  Â  let sceneryLayers = { back: [], mid: [], front: [] };
Â  Â  Â  Â  let isRacing = false;
Â  Â  Â  Â  let raceFinished = false;
Â  Â  Â  Â  let raceStartTime;
Â  Â  Â  Â  let animationFrameId;
Â  Â  Â  Â  let frameCount = 0;
Â  Â  Â  Â  let currentLeaderX = 0;
Â  Â  Â  Â 
Â  Â  Â  Â  let FIXED_FINISH_LINE_X = 0;
Â  Â  Â  Â  let DYNAMIC_FINISH_LINE_X = 0;
Â  Â  Â  Â  let RACE_LENGTH = 4500;
Â  Â  Â  Â  let IDEAL_SPEED_PER_SECOND = 0;
Â  Â  Â  Â  let finishPositions = [];
Â  Â  Â  Â  const RACE_STATES = { SETUP: 'SETUP', PREPARING: 'PREPARING', READY: 'READY' };
Â  Â  Â  Â  let raceState = RACE_STATES.SETUP;
Â  Â  Â  Â  const pokemonData = [];
Â  Â  Â  Â  for (let id = 1; id <= 151; id++) {
Â  Â  Â  Â  Â  Â  pokemonData.push({
Â  Â  Â  Â  Â  Â  Â  Â  id, name: `Poke ${id}`,
Â  Â  Â  Â  Â  Â  Â  Â  imageGif: `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/versions/generation-v/black-white/animated/${id}.gif`,
Â  Â  Â  Â  Â  Â  Â  Â  imagePng: `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${id}.png`,
Â  Â  Â  Â  Â  Â  Â  Â  sprite: null
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }
Â  Â  Â  Â  pokemonData.forEach(p => {
Â  Â  Â  Â  Â  Â  const img = new Image();
Â  Â  Â  Â  Â  Â  img.onload = () => { p.sprite = img; };
Â  Â  Â  Â  Â  Â  img.onerror = () => {
Â  Â  Â  Â  Â  Â  Â  Â  const img2 = new Image();
Â  Â  Â  Â  Â  Â  Â  Â  img2.onload = () => { p.sprite = img2; };
Â  Â  Â  Â  Â  Â  Â  Â  img2.src = p.imagePng;
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  img.src = p.imageGif;
Â  Â  Â  Â  });
Â  Â  Â  Â  const logoImage = new Image();
Â  Â  Â  Â  logoImage.src = 'https://60fb7b08eaf293096e8c.cdn6.editmysite.com/uploads/b/60fb7b08eaf293096e8cb3f63df9e65735b8a1ee75f6d23d21eaed2115dfa2e6/IMG_7388_1701827680.jpeg?width=2400&optimize=medium';
Â  Â  Â  Â 
Â  Â  Â  Â  function getRandomInt(min, max) {
Â  Â  Â  Â  Â  Â  min = Math.ceil(min);
Â  Â  Â  Â  Â  Â  max = Math.floor(max);
Â  Â  Â  Â  Â  Â  return Math.floor(Math.random() * (max - min + 1)) + min;
Â  Â  Â  Â  }
Â  Â  Â  Â 
Â  Â  Â  Â  function formatMMSS(secondsFloat) {
Â  Â  Â  Â  Â  Â  if (isNaN(secondsFloat) || secondsFloat === null || secondsFloat === Infinity) return "DNF";
Â  Â  Â  Â  Â  Â  const total = Math.max(0, secondsFloat);
Â  Â  Â  Â  Â  Â  const mins = Math.floor(total / 60);
Â  Â  Â  Â  Â  Â  const secs = total % 60;
Â  Â  Â  Â  Â  Â  return `${String(mins).padStart(2,'0')}:${String(Math.floor(secs)).padStart(2,'0')}`;
Â  Â  Â  Â  }
Â  Â  Â  Â 
Â  Â  Â  Â  function drawTimer() {
Â  Â  Â  Â  Â  Â  // Timer functionality removed
Â  Â  Â  Â  }
Â  Â  Â  Â  function drawSceneryLayer(layer, parallaxFactor) {
Â  Â  Â  Â  Â  Â  const layerOffset = trackOffset * parallaxFactor;
Â  Â  Â  Â  Â  Â  layer.forEach(obj => {
Â  Â  Â  Â  Â  Â  Â  Â  if (obj.x > layerOffset - 50 && obj.x < layerOffset + canvas.width + 50) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.save();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.translate(obj.x, obj.y);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (obj.type === 'tree') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.scale(obj.scale, obj.scale);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#6a3e1a'; ctx.fillRect(0, 0, 12, 24);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#005400'; ctx.beginPath(); ctx.arc(6, 0, 18, 0, Math.PI * 2); ctx.fill();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (obj.type === 'house') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.scale(obj.scale, obj.scale);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#8B0000';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillRect(0, 0, 50, 40);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#555';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.moveTo(-5, 0); ctx.lineTo(55, 0); ctx.lineTo(25, -25);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else if (obj.type === 'spectator') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.scale(obj.scale, obj.scale);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#008000';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.arc(0, 0, 10, 0, Math.PI * 2); ctx.fill();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#FFDAB9';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.arc(0, -15, 5, 0, Math.PI * 2); ctx.fill();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.restore();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // MODIFIED drawRacer function for sharper text
Â  Â  Â  Â  function drawRacer(racer){
Â  Â  Â  Â  Â  Â  ctx.save();
Â  Â  Â  Â  Â  Â  ctx.translate(racer.x, racer.y);
Â  Â  Â  Â  Â  Â  const strideBob = isRacing ? Math.sin(frameCount / 8 + racer.speedPhase) * 4 : 0;
Â  Â  Â  Â  Â  Â  ctx.translate(0, strideBob);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  if (racer.data.sprite && racer.data.sprite.complete) {
Â  Â  Â  Â  Â  Â  Â  Â  try { ctx.drawImage(racer.data.sprite, -POKEMON_IMAGE_SIZE/2, -POKEMON_IMAGE_SIZE/2, POKEMON_IMAGE_SIZE, POKEMON_IMAGE_SIZE); } catch(e){}
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // **IMPROVED TEXT RENDERING FOR SHARPNESS**
Â  Â  Â  Â  Â  Â  ctx.imageSmoothingEnabled = false; // Prevents the canvas from blurring the sprite/text on transformations
Â  Â  Â  Â  Â  Â  ctx.font = `bold ${NAME_TAG_FONT_SIZE}px "Bebas Neue", sans-serif`; // Ensure custom font is used correctly
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const nameText = racer.name;
Â  Â  Â  Â  Â  Â  const textWidth = ctx.measureText(nameText).width;
Â  Â  Â  Â  Â  Â  const tagY = -POKEMON_IMAGE_SIZE/2 - (NAME_TAG_FONT_SIZE + NAME_TAG_PADDING)/2 - 5;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Draw name tag background
Â  Â  Â  Â  Â  Â  ctx.fillStyle = 'rgba(0,0,0,0.7)';
Â  Â  Â  Â  Â  Â  ctx.strokeStyle = '#aaaaaa';
Â  Â  Â  Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  Â  Â  Â  ctx.fillRect(-textWidth/2 - NAME_TAG_PADDING, tagY - (NAME_TAG_FONT_SIZE + NAME_TAG_PADDING)/2, textWidth + NAME_TAG_PADDING*2, NAME_TAG_FONT_SIZE + NAME_TAG_PADDING);
Â  Â  Â  Â  Â  Â  ctx.strokeRect(-textWidth/2 - NAME_TAG_PADDING, tagY - (NAME_TAG_FONT_SIZE + NAME_TAG_PADDING)/2, textWidth + NAME_TAG_PADDING*2, NAME_TAG_FONT_SIZE + NAME_TAG_PADDING);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Draw name text
Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#FFFFFF';Â 
Â  Â  Â  Â  Â  Â  ctx.textAlign = 'center';Â 
Â  Â  Â  Â  Â  Â  ctx.textBaseline = 'middle';Â 
Â  Â  Â  Â  Â  Â  ctx.fillText(nameText, 0, tagY);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  ctx.restore();
Â  Â  Â  Â  }
Â  Â  Â  Â  // END MODIFIED drawRacer
Â  Â  Â  Â Â 
Â  Â  Â  Â  function drawStartLine(){ ctx.strokeStyle='white'; ctx.lineWidth=8; ctx.beginPath(); ctx.moveTo(START_LINE_X-10, GRASS_AREA_HEIGHT); ctx.lineTo(START_LINE_X-10, canvas.height-GRASS_AREA_HEIGHT); ctx.stroke(); }
Â  Â  Â  Â  function drawFinishLine(){
Â  Â  Â  Â  Â  Â  ctx.save();
Â  Â  Â  Â  Â  Â  const finishX = DYNAMIC_FINISH_LINE_X;
Â  Â  Â  Â  Â  Â  const COLOR_PRIMARY = '#ffffff';
Â  Â  Â  Â  Â  Â  const COLOR_SECONDARY = '#000000';
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  // Draw checkered pattern
Â  Â  Â  Â  Â  Â  const squareSize = 20;
Â  Â  Â  Â  Â  Â  const numSquares = Math.ceil((canvas.height - GRASS_AREA_HEIGHT * 2) / squareSize);
Â  Â  Â  Â  Â  Â  const lineWidth = 60;
Â  Â  Â  Â  Â  Â  const stripeWidth = lineWidth / 2;
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  for (let y = 0; y < numSquares; y++) {
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = (y) % 2 === 0 ? COLOR_PRIMARY : COLOR_SECONDARY;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillRect(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  finishX - lineWidth / 2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  GRASS_AREA_HEIGHT + y * squareSize,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  stripeWidth,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  squareSize
Â  Â  Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = (y) % 2 === 0 ? COLOR_SECONDARY : COLOR_PRIMARY;
Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillRect(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  finishX - lineWidth / 2 + stripeWidth,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  GRASS_AREA_HEIGHT + y * squareSize,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  stripeWidth,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  squareSize
Â  Â  Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  // Draw banner above track
Â  Â  Â  Â  Â  Â  const bannerWidth = 300;
Â  Â  Â  Â  Â  Â  const bannerHeight = 50;
Â  Â  Â  Â  Â  Â  const bannerY = GRASS_AREA_HEIGHT - bannerHeight - 10;
Â  Â  Â  Â  Â  Â  ctx.fillStyle = 'rgba(0,0,0,0.9)';
Â  Â  Â  Â  Â  Â  ctx.fillRect(finishX - bannerWidth / 2, bannerY, bannerWidth, bannerHeight);
Â  Â  Â  Â  Â  Â  ctx.strokeStyle = '#00eaff';
Â  Â  Â  Â  Â  Â  ctx.lineWidth = 6;
Â  Â  Â  Â  Â  Â  ctx.strokeRect(finishX - bannerWidth / 2, bannerY, bannerWidth, bannerHeight);
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  // Draw "FINISH" text on banner
Â  Â  Â  Â  Â  Â  ctx.font = 'bold 42px Orbitron';
Â  Â  Â  Â  Â  Â  ctx.textAlign = 'center';
Â  Â  Â  Â  Â  Â  ctx.textBaseline = 'middle';
Â  Â  Â  Â  Â  Â  ctx.shadowColor = '#00eaff';
Â  Â  Â  Â  Â  Â  ctx.shadowBlur = 15;
Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#00eaff';
Â  Â  Â  Â  Â  Â  ctx.fillText('FINISH LINE', finishX, bannerY + bannerHeight / 2);
Â  Â  Â  Â  Â  Â  ctx.strokeStyle = '#000000';
Â  Â  Â  Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  Â  Â  Â  ctx.strokeText('FINISH LINE', finishX, bannerY + bannerHeight / 2);
Â  Â  Â  Â  Â  Â  ctx.shadowBlur = 0;
Â  Â  Â  Â  Â  Â  ctx.restore();
Â  Â  Â  Â  }
Â  Â  Â  Â  function drawBackgroundAndTrack(){
Â  Â  Â  Â  Â  Â  const currentTrackLength = RACE_LENGTH;
Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#2b6f2b'; ctx.fillRect(0, 0, currentTrackLength, canvas.height);
Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#5a5a5a'; ctx.fillRect(0, GRASS_AREA_HEIGHT, currentTrackLength, canvas.height - (GRASS_AREA_HEIGHT * 2));
Â  Â  Â  Â  }
Â  Â  Â  Â  function drawAll(){
Â  Â  Â  Â  Â  Â  ctx.clearRect(0,0,canvas.width,canvas.height);
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  ctx.save();
Â  Â  Â  Â  Â  Â  ctx.translate(-trackOffset, 0);
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  drawBackgroundAndTrack();
Â  Â  Â  Â  Â  Â  drawSceneryLayer(sceneryLayers.back, 0.3);
Â  Â  Â  Â  Â  Â  drawSceneryLayer(sceneryLayers.mid, 0.6);
Â  Â  Â  Â  Â  Â  drawStartLine();
Â  Â  Â  Â  Â  Â  racers.forEach(drawRacer);
Â  Â  Â  Â  Â  Â  drawFinishLine();
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  ctx.restore();
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  drawTimer();
Â  Â  Â  Â  }
Â  Â  Â  Â  function initRacers() {
Â  Â  Â  Â  Â  Â  racers = [];
Â  Â  Â  Â  Â  Â  const customNamesInput = document.getElementById('racerNames');
Â  Â  Â  Â  Â  Â  let customNames = customNamesInput.value.split('\n').map(name => name.trim()).filter(name => name);
Â  Â  Â  Â  Â  Â  if (customNames.length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  // Using default names if textarea is empty
                customNames = customNamesInput.placeholder.split('\n').map(name => name.trim()).filter(name => name);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  const shuffledPokemon = [...pokemonData].sort(() => 0.5 - Math.random());
Â  Â  Â  Â  Â  Â  const numRacers = Math.min(customNames.length, shuffledPokemon.length);
Â  Â  Â  Â  Â  Â  for (let i = 0; i < numRacers; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  racers.push({
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  name: customNames[i],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  data: shuffledPokemon[i],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  x: START_LINE_X,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  y: GRASS_AREA_HEIGHT + i * laneHeight + laneHeight / 2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  baseSpeed: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  currentSpeed: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  speedPhase: Math.random() * Math.PI * 2,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  surgeActive: false,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isDebuffed: false,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  lastSurgeTime: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  stamina: 100,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  headTurn: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isDrafting: false,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isLeadingSince: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isLastSince: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isLeaderDebuffed: false,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  debuffEndTime: 0,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isLastBoosted: false,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  boostEndTime: 0
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  function reassignPokemons() {
Â  Â  Â  Â  Â  Â  if (racers.length === 0) return;
Â  Â  Â  Â  Â  Â  const shuffledPokemon = [...pokemonData].sort(() => 0.5 - Math.random());
Â  Â  Â  Â  Â  Â  racers.forEach((racer, i) => {
Â  Â  Â  Â  Â  Â  Â  Â  racer.data = shuffledPokemon[i];
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  drawAll();
Â  Â  Â  Â  }
Â  Â  Â  Â  function updateCanvasSettings() {
Â  Â  Â  Â  Â  Â  const isFullscreen = raceView.classList.contains('fullscreen');
Â  Â  Â  Â  Â  Â  
            // Calculate available canvas space based on screen/container size
            if (isFullscreen) {
                CANVAS_VIEWPORT_WIDTH = window.innerWidth;
                CANVAS_VIEWPORT_HEIGHT = window.innerHeight;
            } else {
                const rect = raceView.getBoundingClientRect();
                CANVAS_VIEWPORT_WIDTH = rect.width;
                CANVAS_VIEWPORT_HEIGHT = rect.height;
            }
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  // Race time is now approximate, only used to calculate fixed distance
Â  Â  Â  Â  Â  Â  const targetTime = Math.max(10, Math.min(300, parseInt(document.getElementById('raceTimeSeconds').value) || 60));
Â  Â  Â  Â  Â  Â  TARGET_RACE_TIME_SECONDS = targetTime;
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  const tempFinishX = BASE_SPEED_PER_SECOND * TARGET_RACE_TIME_SECONDS;
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  // FIXED finish line based on target time
Â  Â  Â  Â  Â  Â  FIXED_FINISH_LINE_X = Math.max(2000, Math.round(tempFinishX * 1.5));
Â  Â  Â  Â  Â  Â  DYNAMIC_FINISH_LINE_X = FIXED_FINISH_LINE_X;
Â  Â  Â  Â  Â  Â  RACE_LENGTH = DYNAMIC_FINISH_LINE_X + 1500;
Â  Â  Â  Â  Â  Â  document.getElementById('raceLengthDisplay').value = DYNAMIC_FINISH_LINE_X.toFixed(0);
Â  Â  Â  Â  Â  Â  
            // Scale canvas to the size of its container
            canvas.width = CANVAS_VIEWPORT_WIDTH;
Â  Â  Â  Â  Â  Â  canvas.height = CANVAS_VIEWPORT_HEIGHT;
            
Â  Â  Â  Â  Â  Â  laneHeight = (canvas.height - (GRASS_AREA_HEIGHT * 2)) / Math.max(1, racers.length);
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  IDEAL_SPEED_PER_SECOND = (FIXED_FINISH_LINE_X - START_LINE_X) / TARGET_RACE_TIME_SECONDS;
Â  Â  Â  Â  Â  Â  // MODIFIED: Anchor at 40%
Â  Â  Â  Â  Â  Â  cameraAnchorX = CANVAS_VIEWPORT_WIDTH * FIXED_RACER_X_ANCHOR_PCT;
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  if (racers.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  racers.forEach((racer, index) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  racer.y = GRASS_AREA_HEIGHT + index * laneHeight + laneHeight / 2;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Extreme randomization range (0.85 to 1.15)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  racer.baseSpeed = IDEAL_SPEED_PER_SECOND * (1.0 - 0.15 + Math.random() * 0.3);
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â 
Â  Â  Â  Â  function initScenery() {
Â  Â  Â  Â  Â  Â  sceneryLayers = { back: [], mid: [], front: [] };
Â  Â  Â  Â  Â  Â  const sceneryTypes = ['tree', 'house', 'spectator'];
Â  Â  Â  Â  Â  Â  const numObjects = 60;
Â  Â  Â  Â  Â  Â  for (let i = 0; i < numObjects; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const type = sceneryTypes[Math.floor(Math.random() * sceneryTypes.length)];
Â  Â  Â  Â  Â  Â  Â  Â  const top = Math.random() > 0.5;
Â  Â  Â  Â  Â  Â  Â  Â  const y = top ? Math.random() * (GRASS_AREA_HEIGHT - 30) + 10 : canvas.height - GRASS_AREA_HEIGHT + Math.random() * (GRASS_AREA_HEIGHT - 30) + 10;
Â  Â  Â  Â  Â  Â  Â  Â  if (Math.random() < 0.3) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  sceneryLayers.back.push({ type, x: Math.random() * RACE_LENGTH * 1.2, y, scale: 0.7 });
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  sceneryLayers.mid.push({ type, x: Math.random() * RACE_LENGTH, y, scale: 1.0 });
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  function updateRacers(deltaTimeSeconds){
Â  Â  Â  Â  Â  Â  if (!raceStartTime) return;
Â  Â  Â  Â  Â  Â  const now = performance.now();
Â  Â  Â  Â  Â  Â  const elapsedMilliseconds = now - raceStartTime;
Â  Â  Â  Â  Â  Â  let elapsedSeconds = elapsedMilliseconds / 1000;
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  const sortedRacers = [...racers].sort((a, b) => b.x - a.x);
Â  Â  Â  Â  Â  Â  let leader = sortedRacers[0];
Â  Â  Â  Â  Â  Â  let lastRacer = sortedRacers[sortedRacers.length - 1];
Â  Â  Â  Â  Â  Â  if (!leader || !lastRacer) return;
Â  Â  Â  Â  Â  Â  const currentTime = performance.now();
Â  Â  Â  Â  Â  Â  racers.forEach(racer => {
Â  Â  Â  Â  Â  Â  Â  Â  // Decay the positional effects if their time is up
Â  Â  Â  Â  Â  Â  Â  Â  if (racer.debuffEndTime > 0 && currentTime > racer.debuffEndTime) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  racer.isLeaderDebuffed = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  racer.debuffEndTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (racer.boostEndTime > 0 && currentTime > racer.boostEndTime) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  racer.isLastBoosted = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  racer.boostEndTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  // --- Leader Debuff Logic ---
Â  Â  Â  Â  Â  Â  Â  Â  if (racer === leader) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!racer.isLeaderDebuffed) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (racer.isLeadingSince === 0) racer.isLeadingSince = currentTime;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentTime - racer.isLeadingSince > LEADER_DEBUFF_COOLDOWN) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  racer.isLeaderDebuffed = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  racer.debuffEndTime = currentTime + LEADER_DEBUFF_DURATION;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  racer.isLeadingSince = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  racer.isLastSince = 0;
Â  Â  Â  Â  Â  Â  Â  Â  } else if (racer.isLeadingSince !== 0 && !racer.isLeaderDebuffed) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  racer.isLeadingSince = 0;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  // --- Last Place Boost Logic ---
Â  Â  Â  Â  Â  Â  Â  Â  if (racer === lastRacer) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!racer.isLastBoosted) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (racer.isLastSince === 0) racer.isLastSince = currentTime;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (currentTime - racer.isLastSince > LAST_BOOST_COOLDOWN) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  racer.isLastBoosted = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  racer.boostEndTime = currentTime + LAST_BOOST_DURATION;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  racer.isLastSince = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  racer.isLeadingSince = 0;
Â  Â  Â  Â  Â  Â  Â  Â  } else if (racer.isLastSince !== 0 && !racer.isLastBoosted) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  racer.isLastSince = 0;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  // 3. Update Racer Speeds with Modifiers
Â  Â  Â  Â  Â  Â  const packCenterX = racers.reduce((sum, r) => sum + r.x, 0) / racers.length;
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  racers.forEach(racer => {
Â  Â  Â  Â  Â  Â  Â  Â  if (racer.stamina < 100) racer.stamina = Math.min(100, racer.stamina + STAMINA_REGEN_RATE * deltaTimeSeconds);
Â  Â  Â  Â  Â  Â  Â  Â  const staminaModifier = 0.7 + 0.3 * (racer.stamina / 100);
Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  const distanceFromCenter = racer.x - packCenterX;
Â  Â  Â  Â  Â  Â  Â  Â  // RUBBER BANDING IS REMOVED
Â  Â  Â  Â  Â  Â  Â  Â  const rubberBandAdjustment = -distanceFromCenter * 0.00;
Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  const volatility = 1.0 + (Math.random() * VOLATILITY_SWING * 2 - VOLATILITY_SWING);
Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  let naturalSpeed = racer.baseSpeed * BASE_MOMENTUM_FACTOR * staminaModifier + rubberBandAdjustment;
Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  naturalSpeed *= volatility;
Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (racer.surgeActive) naturalSpeed *= SURGE_MULTIPLIER;
Â  Â  Â  Â  Â  Â  Â  Â  if (racer.isDebuffed) naturalSpeed *= DEBUFF_MULTIPLIER;
Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (racer === activeShortBooster) naturalSpeed *= SHORT_BOOST_MULTIPLIER;
Â  Â  Â  Â  Â  Â  Â  Â  if (racer === activeShortDebuffer) naturalSpeed *= SHORT_DEBUFF_MULTIPLIER;
Â  Â  Â  Â  Â  Â  Â  Â  if (racer.isLeaderDebuffed) naturalSpeed *= LEADER_DEBUFF_MULTIPLIER;
Â  Â  Â  Â  Â  Â  Â  Â  if (racer.isLastBoosted) naturalSpeed *= LAST_BOOST_MULTIPLIER;
Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  // NO SYNCHRONIZATION LOGIC APPLIED
Â  Â  Â  Â  Â  Â  Â  Â  racer.currentSpeed = Math.max(1, naturalSpeed);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  // 4. Race ends when the FIRST racer crosses the line.
Â  Â  Â  Â  Â  Â  let firstFinisher = null;
Â  Â  Â  Â  Â  Â  let timeToFinish = Infinity;
Â  Â  Â  Â  Â  Â  for (const racer of racers) {
Â  Â  Â  Â  Â  Â  Â  Â  racer.nextX = racer.x + racer.currentSpeed * deltaTimeSeconds;
Â  Â  Â  Â  Â  Â  Â  Â  if (racer.nextX >= DYNAMIC_FINISH_LINE_X && racer.x < DYNAMIC_FINISH_LINE_X) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const distToFinish = DYNAMIC_FINISH_LINE_X - racer.x;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const ttF = distToFinish / racer.currentSpeed;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (ttF < timeToFinish) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  timeToFinish = ttF;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  firstFinisher = racer;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (firstFinisher) {
Â  Â  Â  Â  Â  Â  Â  Â  isRacing = false;
Â  Â  Â  Â  Â  Â  Â  Â  raceFinished = true;
Â  Â  Â  Â  Â  Â  Â  Â  cancelAnimationFrame(animationFrameId);
Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Calculate precise finish time
Â  Â  Â  Â  Â  Â  Â  Â  const finalRaceTime = elapsedSeconds + timeToFinish;
Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  firstFinisher.x = DYNAMIC_FINISH_LINE_X;
Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  captureFinishPositions(finalRaceTime);
Â  Â  Â  Â  Â  Â  Â  Â  showWinnerAnimation(firstFinisher.name);
Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  requestAnimationFrame(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  drawAll();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  winnerOverlay.style.display = 'none';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  raceView.classList.remove('fullscreen');
                        controlPanel.style.display = 'block'; // Show controls again
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  displayFinalLeaderboard();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  leaderboard.style.display = 'flex';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  leaderboard.classList.add('fullscreen');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  postRaceControls.style.display = 'flex';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, 3000);
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  // 5. Final Position Update
Â  Â  Â  Â  Â  Â  racers.forEach(racer => {
Â  Â  Â  Â  Â  Â  Â  Â  racer.x += racer.currentSpeed * deltaTimeSeconds;
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }
Â  Â  Â  Â  function updateCamera(){
Â  Â  Â  Â  Â  Â  if (!isRacing && !raceFinished) { trackOffset = 0; return; };
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  const currentLeaderX = racers.reduce((max, r) => Math.max(max, r.x), 0);
Â  Â  Â  Â  Â  Â  const minX = racers.reduce((min, r) => Math.min(min, r.x), currentLeaderX);
Â  Â  Â  Â  Â  Â  let desiredOffset = currentLeaderX - cameraAnchorX;
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  const minAllowedOffset = Math.max(0, minX - CANVAS_VIEWPORT_WIDTH * 0.1);
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  desiredOffset = Math.max(minAllowedOffset, desiredOffset);
Â  Â  Â  Â  Â  Â  const maxOffset = Math.max(0, RACE_LENGTH - CANVAS_VIEWPORT_WIDTH);
Â  Â  Â  Â  Â  Â  desiredOffset = Math.min(desiredOffset, maxOffset);
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  trackOffset += (desiredOffset - trackOffset) * CAMERA_SMOOTHING_FACTOR;
Â  Â  Â  Â  }
Â  Â  Â  Â  function animate(currentTime){
Â  Â  Â  Â  Â  Â  if (!lastFrameTime) lastFrameTime = currentTime;
Â  Â  Â  Â  Â  Â  const deltaTimeSeconds = (currentTime - lastFrameTime) / 1000;
Â  Â  Â  Â  Â  Â  lastFrameTime = currentTime;
Â  Â  Â  Â  Â  Â  frameCount++;
Â  Â  Â  Â  Â  Â  if (isRacing) {
Â  Â  Â  Â  Â  Â  Â  Â  updateRacers(deltaTimeSeconds);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  updateCamera();
Â  Â  Â  Â  Â  Â  drawAll();
Â  Â  Â  Â  Â  Â  if (!raceFinished) {
Â  Â  Â  Â  Â  Â  Â  Â  animationFrameId = requestAnimationFrame(animate);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  function captureFinishPositions(winnerTime){
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  finishPositions = racers.map(r => {
Â  Â  Â  Â  Â  Â  Â  Â  let resultTime;
Â  Â  Â  Â  Â  Â  Â  Â  if (r.x >= DYNAMIC_FINISH_LINE_X) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  resultTime = winnerTime;
Â  Â  Â  Â  Â  Â  Â  Â  } else if (r.currentSpeed > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â const distanceRemaining = DYNAMIC_FINISH_LINE_X - r.x;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â const timeRemaining = distanceRemaining / r.currentSpeed;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â resultTime = winnerTime + timeRemaining;
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  resultTime = Infinity;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  Â  Â  return { name: r.name, finalX: r.x, currentSpeed: r.currentSpeed, resultTime };
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  finishPositions.sort((a, b) => {
Â  Â  Â  Â  Â  Â  Â  Â  if (a.resultTime === Infinity) return 1;
Â  Â  Â  Â  Â  Â  Â  Â  if (b.resultTime === Infinity) return -1;
Â  Â  Â  Â  Â  Â  Â  Â  return a.resultTime - b.resultTime;
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }
Â  Â  Â  Â  function displayFinalLeaderboard(){
Â  Â  Â  Â  Â  Â  document.getElementById('leaderboardTitle').textContent = 'ğŸ FINAL RACE RESULTS ğŸ†';
Â  Â  Â  Â  Â  Â  const listContainer = document.getElementById('leaderboardList');
Â  Â  Â  Â  Â  Â  listContainer.innerHTML = finishPositions.map((r, i) => {
Â  Â  Â  Â  Â  Â  Â  Â  const rank = i + 1;
Â  Â  Â  Â  Â  Â  Â  Â  const isWinner = rank === 1;
Â  Â  Â  Â  Â  Â  Â  Â  const rankDisplay = isWinner ? `<span class="trophy">ğŸ†</span> 1.` : `${rank}.`;
Â  Â  Â  Â  Â  Â  Â  Â  return `<div class="leaderboard-entry ${isWinner ? 'winner-entry' : ''}">
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span class="rank-number">${rankDisplay}</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <strong class="racer-name-leaderboard">${r.name}</strong>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  <span class="time-result">${formatMMSS(r.resultTime)}</span>
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  </div>`;
Â  Â  Â  Â  Â  Â  }).join('');
Â  Â  Â  Â  }
Â  Â  Â  Â  function submitNames(){
Â  Â  Â  Â  Â  Â  const customNames = document.getElementById('racerNames').value.split('\n').map(name => name.trim()).filter(Boolean);
            // Removed submittedNames div logic as it's no longer used
            if (customNames.length === 0) {
                statusDisplay.textContent = 'Please enter at least one racer name.';
                return;
            }
Â  Â  Â  Â  Â  Â  statusDisplay.textContent = `Submitted ${customNames.length} racer${customNames.length===1?'':'s'}. Ready to roll!`;
Â  Â  Â  Â  Â  Â  initRacers();
Â  Â  Â  Â  Â  Â  updateCanvasSettings();
Â  Â  Â  Â  Â  Â  drawAll();
Â  Â  Â  Â  }
Â  Â  Â  Â  function handleStartButton(){
Â  Â  Â  Â  Â  Â  if (racers.length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  submitNames();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  if (racers.length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  statusDisplay.textContent = 'Please enter at least one racer name before starting.';
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  if (raceState === RACE_STATES.SETUP) prepareRace();
Â  Â  Â  Â  Â  Â  else if (raceState === RACE_STATES.PREPARING) startRace();
Â  Â  Â  Â  }
Â  Â  Â  Â  function prepareRace(){
Â  Â  Â  Â  Â  Â  raceState = RACE_STATES.PREPARING;
Â  Â  Â  Â  Â  Â  controlPanel.style.display = 'none'; 
Â  Â  Â  Â  Â  Â  raceView.style.display = 'flex'; 
Â  Â  Â  Â  Â  Â  raceControls.style.display = 'flex';
Â  Â  Â  Â  Â  Â  raceView.classList.add('fullscreen');
Â  Â  Â  Â  Â  Â  initRacers(); 
            updateCanvasSettings(); 
            initScenery(); 
            drawAll();
Â  Â  Â  Â  Â  Â  statusDisplay.textContent = 'PREPARE: Click START RACE (GO!).';
Â  Â  Â  Â  }
Â  Â  Â  Â  function startRace(){
Â  Â  Â  Â  Â  Â  raceState = RACE_STATES.READY; isRacing = true; raceFinished = false;
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  lastBoostTime = performance.now();
Â  Â  Â  Â  Â  Â  activeShortBooster = null;
Â  Â  Â  Â  Â  Â  lastDebuffTime = performance.now();
Â  Â  Â  Â  Â  Â  activeShortDebuffer = null;
Â  Â  Â  Â  Â  Â 
Â  Â  Â  Â  Â  Â  racers.forEach(r => {
Â  Â  Â  Â  Â  Â  Â  Â  r.isLeadingSince = 0;
Â  Â  Â  Â  Â  Â  Â  Â  r.isLastSince = 0;
Â  Â  Â  Â  Â  Â  Â  Â  r.isLeaderDebuffed = false;
Â  Â  Â  Â  Â  Â  Â  Â  r.debuffEndTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  r.isLastBoosted = false;
Â  Â  Â  Â  Â  Â  Â  Â  r.boostEndTime = 0;
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  raceStartTime = performance.now();
Â  Â  Â  Â  Â  Â  lastFrameTime = performance.now();
Â  Â  Â  Â  Â  Â  statusDisplay.textContent = 'GO! RACE HAS BEGUN!';
Â  Â  Â  Â  Â  Â  raceControls.style.display = 'none';
Â  Â  Â  Â  Â  Â  cancelAnimationFrame(animationFrameId); animationFrameId = requestAnimationFrame(animate);
Â  Â  Â  Â  }
Â  Â  Â  Â  function resetRace(){
Â  Â  Â  Â  Â  Â  raceState = RACE_STATES.SETUP; isRacing = false; raceFinished = false;
Â  Â  Â  Â  Â  Â  cancelAnimationFrame(animationFrameId);
Â  Â  Â  Â  Â  Â  winnerOverlay.style.display = 'none'; leaderboard.style.display = 'none';
Â  Â  Â  Â  Â  Â  leaderboard.classList.remove('fullscreen');
Â  Â  Â  Â  Â  Â  controlPanel.style.display = 'block'; 
            raceView.style.display = 'flex'; // Keep raceView displayed to show initial canvas in mainContent flow
Â  Â  Â  Â  Â  Â  raceView.classList.remove('fullscreen');
Â  Â  Â  Â  Â  Â  postRaceControls.style.display = 'none';
Â  Â  Â  Â  Â  Â  statusDisplay.textContent = 'Systems nominal. Enter names to begin.';
Â  Â  Â  Â  Â  Â  initRacers();
Â  Â  Â  Â  Â  Â  updateCanvasSettings();
Â  Â  Â  Â  Â  Â  drawAll();
Â  Â  Â  Â  }
Â  Â  Â  Â  function showWinnerAnimation(winnerName){
Â  Â  Â  Â  Â  Â  document.getElementById('winnerName').textContent = winnerName + " WINS!";
Â  Â  Â  Â  Â  Â  winnerOverlay.style.display = 'flex';
Â  Â  Â  Â  }
Â  Â  Â  Â  submitNamesButton.addEventListener('click', submitNames);
Â  Â  Â  Â  setupStartButton.addEventListener('click', handleStartButton);
Â  Â  Â  Â  raceScreenStartButton.addEventListener('click', handleStartButton);
Â  Â  Â  Â  shuffleButton.addEventListener('click', reassignPokemons);
Â  Â  Â  Â  window.addEventListener('resize', () => {
Â  Â  Â  Â  Â  Â  // Only update settings if not on the initial setup screen and if race view is active
            if (raceView.style.display === 'flex') {
Â  Â  Â  Â  Â  Â  Â  Â  updateCanvasSettings(); 
                initScenery(); 
                drawAll();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  Â  
        // Initial setup for the redesigned layout
        document.addEventListener('DOMContentLoaded', () => {
            // Ensure the main setup elements are visible initially
            // The raceView is hidden by CSS rules now, so we need to ensure the container is visible
            controlPanel.style.display = 'block'; 
            raceView.style.display = 'flex';
            
            // Re-initialize race elements for canvas drawing in the window
            initRacers();
            updateCanvasSettings();
            initScenery();
            drawAll();
        });

Â  Â  </script>
</body>
</html>
