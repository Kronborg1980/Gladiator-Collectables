<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gladiators Death Wheel - TRON EDITION</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* --- TRON THEME VARIABLES --- */
        :root {
            --tron-blue: #00FFFF; /* Primary Neon: Cyan/Blue */
            --tron-red: #FF0055; /* Death/Elimination: Deep Red/Pink */
            --tron-green: #39FF14; /* Success/Champion: Neon Green */
            --dark-metal: #101010;
            --light-metal: #333333;
            --text-white: #FFFFFF; /* Pure white for contrast */
        }

        /* --- GLOBAL & UTILITY STYLES --- */
        .tron-background {
            /* Adds a subtle repeating grid pattern for a high-tech/matrix feel */
            background-color: #0A0A0A;
            background-image: linear-gradient(0deg, transparent 95%, rgba(0, 255, 255, 0.05) 100%),
                              linear-gradient(90deg, transparent 95%, rgba(0, 255, 255, 0.05) 100%);
            background-size: 25px 25px;
        }

        /* üéØ UPDATED: Using the neon-title-glow from your index.html */
        .neon-title-glow {
            text-shadow: 0 0 5px #fff, 0 0 10px var(--tron-blue), 0 0 20px var(--tron-blue), 0 0 40px var(--tron-blue);
            color: var(--text-white); /* Ensure the base text color is white before glow */
        }

        .metal-panel {
            background: linear-gradient(145deg, var(--dark-metal), #000000);
            border: 1px solid var(--light-metal);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.15), inset 0 0 3px var(--light-metal);
        }

        /* --- WHEEL & POINTER STYLES --- */
        #wheel-canvas {
            border: 10px solid var(--dark-metal); /* Darker, thicker metal rim */
            border-radius: 50%;
            box-shadow: 0 0 40px var(--tron-blue), 0 0 15px var(--tron-blue);
        }

        #pointer {
            position: absolute;
            top: -35px; /* Moved closer to the wheel */
            left: 50%;
            transform: translateX(-50%); /* Centered horizontally */
            width: 0;
            height: 0;
            border-left: 10px solid transparent; /* MUCH SLIMMER BASE */
            border-right: 10px solid transparent; /* MUCH SLIMMER BASE */
            border-top: 40px solid var(--text-white); /* SHORTER AND SLIMMER BODY */
            z-index: 10;
            
            /* Add intense neon blue glow */
            filter: drop-shadow(0 0 18px var(--tron-blue));
            box-shadow: 0 0 10px var(--tron-blue);
        }

        @keyframes pointerBounce {
            0% { transform: translateX(-50%) rotate(-8deg); }
            100% { transform: translateX(-50%) rotate(8deg); }
        }
        .pointer-bouncing {
            animation: pointerBounce 0.1s infinite alternate;
        }

        /* --- CONTROL PANEL STYLES --- */
        #spin-button {
            background-color: var(--tron-blue) !important;
            color: var(--dark-metal) !important;
            box-shadow: 0 0 20px var(--tron-blue), 0 0 40px var(--tron-blue);
            transition: all 0.2s;
        }
        #spin-button:hover:not(:disabled) {
            transform: scale(1.03);
            box-shadow: 0 0 30px var(--tron-blue), 0 0 50px var(--tron-blue);
        }

        #elimination-button {
            background-color: var(--tron-red) !important;
            box-shadow: 0 0 20px var(--tron-red), 0 0 40px var(--tron-red);
        }

        /* --- RESULT BOX STYLES --- */
        #result-box {
            border: 4px solid var(--tron-blue);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5), inset 0 0 10px rgba(0, 255, 255, 0.5);
            color: var(--text-white);
        }
        .death-glow {
            border-color: var(--tron-red) !important;
            box-shadow: 0 0 20px var(--tron-red), inset 0 0 15px var(--tron-red);
        }
        .success-glow {
            border-color: var(--tron-green) !important;
            box-shadow: 0 0 20px var(--tron-green), inset 0 0 15px var(--tron-green);
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-neon': 'var(--tron-blue)',
                        'secondary-neon': 'var(--tron-red)',
                        'dark-bg': '#0A0A0A',
                        'text-neon': 'var(--text-white)',
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
</head>
<body class="tron-background min-h-screen p-4 font-sans flex flex-col items-center text-text-neon">

    <h1 class="text-5xl font-extrabold mt-4 mb-8 text-center uppercase neon-title-glow">
        Gladiators Death Wheel
    </h1>
    <hr class="w-2/3 border-t-2 border-tron-blue/50 shadow-lg mb-8" style="box-shadow: 0 0 10px var(--tron-blue);">

    <div class="flex flex-col lg:flex-row w-full max-w-7xl gap-10">

        <div class="lg:w-1/3 p-8 rounded-xl shadow-2xl h-fit metal-panel">
            <h2 class="text-3xl font-bold mb-6 text-primary-neon border-b border-tron-blue/50 pb-2">Control Chamber</h2>

            <label for="names-input" class="block text-sm font-medium text-text-neon/80 mb-2">
                Contestants (One name per line):
            </label>
            <textarea id="names-input" rows="8" class="w-full p-3 border border-primary-neon/50 bg-gray-900 text-text-neon rounded-lg focus:ring-primary-neon focus:border-primary-neon transition duration-150 shadow-inner" placeholder="E.g.,&#10;Kaelen&#10;Maximus&#10;Zeva&#10;Orion&#10;Aura"></textarea>

            <label for="spin-duration" class="block text-sm font-medium text-text-neon/80 mt-6 mb-2">
                Spin Duration (seconds):
            </label>
            <input type="number" id="spin-duration" value="5" min="1" max="60" class="w-full p-3 border border-primary-neon/50 bg-gray-900 text-text-neon rounded-lg focus:ring-primary-neon focus:border-primary-neon transition duration-150 shadow-inner text-center" />

            <button id="spin-button" class="w-full mt-8 py-5 px-4 font-extrabold uppercase rounded-xl shadow-md hover:opacity-95 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed">
                THE FATE SPIN
            </button>
            
            <button id="elimination-button" class="w-full mt-4 py-5 px-4 font-extrabold uppercase rounded-xl shadow-md disabled:opacity-50 disabled:cursor-not-allowed">
                Initiate Deathmatch 
            </button>
        </div>

        <div class="lg:w-2/3 p-8 rounded-xl shadow-2xl flex flex-col items-center metal-panel">
            
            <div id="result-box" class="w-full text-center mb-8 h-28 flex flex-col items-center justify-center rounded-lg bg-dark-metal/50 p-3 transition-all duration-300">
                <p class="text-xl font-bold text-tron-blue/90 uppercase">Current Status:</p>
                <p id="winner-text" class="text-3xl font-extrabold text-white">Awaits the Gladiator's Choice.</p>
            </div>

            <div id="wheel-area" class="w-full max-w-lg aspect-square flex justify-center items-center">
                <div id="wheel-wrapper" class="relative">
                    
                    <div id="pointer"></div> 
                    <div id="pointer-winner-label" class="hidden absolute top-[-10px] left-1/2 -translate-x-1/2 z-20 px-3 py-1 text-xs font-bold rounded-full bg-tron-green text-dark-metal uppercase transition-opacity"></div>
                    
                    <div id="wheel-container" style="width: 100%; height: 100%;">
                        <canvas id="wheel-canvas" class="w-full h-full"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Constants
        const CANVAS_SIZE = 500;
        const LOGO_URL = 'https://60fb7b08eaf293096e8c.cdn6.editmysite.com/uploads/b/60fb7b08eaf293096e8cb3f63df9e65735b8a1ee75f6d23d21eaed2115dfa2e6/IMG_7388_1701827680.jpeg?width=2400&optimize=medium';
        const ELIMINATION_SPIN_DURATION = 5; 
        const TEXT_COLOR = '#FFFFFF'; // Pure white for names

        // Distinct, neon colors for the segments (Kept varied colors for visibility)
        const VIBRANT_COLORS = [
            '#00FFFF', // Cyan
            '#FF00FF', // Magenta
            '#39FF14', // Neon Green
            '#FFFF00', // Neon Yellow
            '#FF1493', // Deep Pink
            '#1E90FF', // Dodger Blue
            '#9370DB', // Medium Purple
            '#00FA9A', // Medium Spring Green
            '#FF4500', // Orange Red
            '#7B68EE', // Medium Slate Blue
            '#FF6347', // Tomato
            '#00FF00', // Lime
            '#D8BFD8', // Thistle
            '#ADD8E6', // Light Blue
            '#F08080'  // Light Coral
        ];

        // DOM Elements
        const canvas = document.getElementById('wheel-canvas');
        const ctx = canvas.getContext('2d');
        const wheelContainer = document.getElementById('wheel-container');
        const pointer = document.getElementById('pointer'); 
        const pointerWinnerLabel = document.getElementById('pointer-winner-label'); 
        const namesInput = document.getElementById('names-input');
        const spinDurationInput = document.getElementById('spin-duration');
        const spinButton = document.getElementById('spin-button');
        const eliminationButton = document.getElementById('elimination-button');
        const winnerText = document.getElementById('winner-text');
        const resultBox = document.getElementById('result-box');

        // State
        let wheelData = [];
        let logoImage = null;
        let isSpinning = false;
        let currentEliminationParticipants = [];

        canvas.width = CANVAS_SIZE;
        canvas.height = CANVAS_SIZE;

        function loadLogo() {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => {
                    logoImage = img;
                    resolve(true);
                };
                img.onerror = () => {
                    console.error("Failed to load logo image. Using text placeholder.");
                    resolve(false);
                };
                img.src = LOGO_URL;
            });
        }

        function prepareWheelData() {
            const names = namesInput.value
                .split('\n')
                .map(name => name.trim())
                .filter(name => name.length > 0);

            if (names.length === 0) {
                wheelData = [];
                drawWheel();
                return;
            }

            wheelData = names.map((name, index) => ({
                name: name,
                color: VIBRANT_COLORS[index % VIBRANT_COLORS.length],
            }));
            
            drawWheel();
        }

        /**
         * Draws the entire wheel on the canvas.
         */
        function drawWheel() {
            const size = canvas.width;
            const dataToDraw = wheelData;

            if (dataToDraw.length === 0) {
                ctx.clearRect(0, 0, size, size);
                winnerText.textContent = "Awaits the Gladiator's Choice.";
                return;
            }

            const centerX = size / 2;
            const centerY = size / 2;
            const radius = size / 2 - 10;

            const segmentAngle = 2 * Math.PI / dataToDraw.length;
            let currentAngle = 0;

            ctx.clearRect(0, 0, size, size);

            // 1. Draw Segments and Text
            dataToDraw.forEach((item) => {
                const startAngle = currentAngle;
                const endAngle = currentAngle + segmentAngle;

                // Draw Segment
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = item.color;
                ctx.fill();

                // Draw Text (White with shadow)
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(startAngle + segmentAngle / 2);

                ctx.fillStyle = TEXT_COLOR; // PURE WHITE TEXT
                ctx.shadowColor = 'var(--tron-blue)';
                ctx.shadowBlur = 5; /* Slightly stronger glow for readability */
                ctx.font = `bold ${Math.floor(size * 0.035)}px Inter`; 
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';

                const textX = radius * 0.9;
                ctx.fillText(item.name.toUpperCase(), textX, 0);

                ctx.restore();
                currentAngle = endAngle;
            });
            ctx.shadowBlur = 0;

            // 2. Draw Pegs (Needles) - White Core, Blue Glow
            const numPegs = dataToDraw.length;
            const pegRadius = radius - 5; /* Slightly inside the rim */
            const pegSize = size * 0.015; /* Larger pegs */

            for (let i = 0; i < numPegs; i++) {
                const angle = (i + 1) * segmentAngle;

                const x = centerX + pegRadius * Math.cos(angle);
                const y = centerY + pegRadius * Math.sin(angle);

                ctx.save();
                
                // Peg Glow
                ctx.beginPath();
                ctx.arc(x, y, pegSize + 3, 0, 2 * Math.PI); /* Glow slightly larger than core */
                ctx.fillStyle = 'var(--tron-blue)';
                ctx.shadowColor = 'var(--tron-blue)';
                ctx.shadowBlur = 12; /* Stronger glow */
                ctx.fill();

                // Peg Core (White/Metallic)
                ctx.beginPath();
                ctx.arc(x, y, pegSize, 0, 2 * Math.PI);
                ctx.fillStyle = 'var(--text-white)'; 
                ctx.shadowBlur = 0; 
                ctx.fill();

                ctx.restore();
            }
            ctx.shadowBlur = 0;

            // 3. Draw Center Hub (Metallic with Neon Ring)
            const logoRadius = radius * 0.25;
            
            // Neon Ring
            ctx.beginPath();
            ctx.arc(centerX, centerY, logoRadius + 10, 0, 2 * Math.PI); /* Thicker ring */
            ctx.fillStyle = 'var(--tron-blue)';
            ctx.shadowColor = 'var(--tron-blue)';
            ctx.shadowBlur = 20; /* More intense glow */
            ctx.fill();

            // Inner Metallic Core
            ctx.beginPath();
            ctx.arc(centerX, centerY, logoRadius, 0, 2 * Math.PI);
            const gradient = ctx.createRadialGradient(centerX, centerY, logoRadius * 0.2, centerX, centerY, logoRadius); /* Gradient refined */
            gradient.addColorStop(0, '#EEEEEE'); /* Lighter center */
            gradient.addColorStop(1, '#333333'); /* Darker edge */
            ctx.fillStyle = gradient;
            ctx.shadowBlur = 0;
            ctx.fill();
            
            // 4. Draw Logo/Placeholder
            if (logoImage) {
                const imgSize = logoRadius * 1.8;
                ctx.save();
                ctx.beginPath();
                ctx.arc(centerX, centerY, logoRadius, 0, Math.PI * 2);
                ctx.clip(); 
                ctx.drawImage(logoImage, centerX - imgSize / 2, centerY - imgSize / 2, imgSize, imgSize);
                ctx.restore();
            } else {
                ctx.fillStyle = 'var(--text-white)';
                ctx.font = `bold ${Math.floor(size * 0.04)}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText("TRON", centerX, centerY);
            }
        }

        // --- SPIN LOGIC ---
        function spinWheel() {
            if (isSpinning || wheelData.length === 0) return;
            isSpinning = true;
            spinButton.disabled = true;
            eliminationButton.disabled = true; 
            namesInput.disabled = true;
            spinDurationInput.disabled = true;

            winnerText.textContent = "Spinning...";
            pointer.classList.add('pointer-bouncing'); 
            pointerWinnerLabel.classList.remove('show-winner-label'); 
            resultBox.classList.remove('success-glow', 'death-glow');

            let duration = parseFloat(spinDurationInput.value) || 5;

            const dataToSpin = wheelData;
            const numSegments = dataToSpin.length;
            const segmentAngleDegrees = 360 / numSegments;
            const currentTransform = wheelContainer.style.transform;
            let currentRotation = 0;
            const match = currentTransform.match(/rotate\(([-+]?\d*\.?\d+)/);
            if (match) currentRotation = parseFloat(match[1]);

            const winningIndex = Math.floor(Math.random() * numSegments);
            const winnerName = dataToSpin[winningIndex].name;

            let targetSegmentMidpoint = winningIndex * segmentAngleDegrees + (segmentAngleDegrees / 2);
            const pointerAngle = 270; 
            let landingAngleOffset = pointerAngle - targetSegmentMidpoint;

            const MAX_JITTER_RANGE = segmentAngleDegrees * 0.4; 
            const randomJitterOffset = (Math.random() * (2 * MAX_JITTER_RANGE)) - MAX_JITTER_RANGE;
            landingAngleOffset += randomJitterOffset;

            const normalizedCurrentRotation = currentRotation % 360;
            let deltaRotation = landingAngleOffset - normalizedCurrentRotation;
            if (deltaRotation < 0) deltaRotation += 360;

            const fullRotations = 5;
            const totalRotation = currentRotation + (fullRotations * 360) + deltaRotation;
            
            wheelContainer.style.transition = `transform ${duration}s cubic-bezier(0.1, 0.7, 0.4, 1)`;
            wheelContainer.style.transform = `rotate(${totalRotation}deg)`;

            setTimeout(() => {
                pointer.classList.remove('pointer-bouncing'); 

                winnerText.textContent = `WINNER: ${winnerName.toUpperCase()}! üèÜ`;
                
                pointerWinnerLabel.textContent = winnerName.toUpperCase();
                pointerWinnerLabel.classList.add('show-winner-label');

                resultBox.classList.add('success-glow');

                isSpinning = false;
                spinButton.disabled = false;
                eliminationButton.disabled = false;
                namesInput.disabled = false;
                spinDurationInput.disabled = false;
            }, duration * 1000 + 50);
        }

        function eliminationSpinCycle() {
            if (currentEliminationParticipants.length <= 1) {
                const finalWinner = currentEliminationParticipants[0];
                winnerText.textContent = `ULTIMATE CHAMPION: ${finalWinner ? finalWinner.name.toUpperCase() : 'NO ONE'} WINS! üëë`;
                
                resultBox.classList.remove('death-glow');
                resultBox.classList.add('success-glow');

                isSpinning = false;
                spinButton.disabled = false;
                eliminationButton.disabled = false;
                namesInput.disabled = false;
                spinDurationInput.disabled = false;
                pointerWinnerLabel.classList.remove('show-winner-label');
                return;
            }

            isSpinning = true;
            winnerText.textContent = `ELIMINATION ROUND: ${currentEliminationParticipants.length} remain...`;
            pointer.classList.add('pointer-bouncing'); 
            pointerWinnerLabel.classList.remove('show-winner-label'); 
            resultBox.classList.remove('success-glow');

            const duration = ELIMINATION_SPIN_DURATION; 
            const dataToSpin = currentEliminationParticipants;
            const numSegments = dataToSpin.length;
            const segmentAngleDegrees = 360 / numSegments;
            const currentTransform = wheelContainer.style.transform;
            let currentRotation = 0;
            const match = currentTransform.match(/rotate\(([-+]?\d*\.?\d+)/);
            if (match) currentRotation = parseFloat(match[1]);

            const winningIndex = Math.floor(Math.random() * numSegments);
            const winnerData = dataToSpin[winningIndex];

            let targetSegmentMidpoint = winningIndex * segmentAngleDegrees + (segmentAngleDegrees / 2);
            const pointerAngle = 270; 
            let landingAngleOffset = pointerAngle - targetSegmentMidpoint;

            const MAX_JITTER_RANGE = segmentAngleDegrees * 0.4; 
            const randomJitterOffset = (Math.random() * (2 * MAX_JITTER_RANGE)) - MAX_JITTER_RANGE;
            landingAngleOffset += randomJitterOffset;

            const normalizedCurrentRotation = currentRotation % 360;
            let deltaRotation = landingAngleOffset - normalizedCurrentRotation;
            if (deltaRotation < 0) deltaRotation += 360;

            const fullRotations = 5;
            const totalRotation = currentRotation + (fullRotations * 360) + deltaRotation;
            
            wheelContainer.style.transition = `transform ${duration}s cubic-bezier(0.1, 0.7, 0.4, 1)`;
            wheelContainer.style.transform = `rotate(${totalRotation}deg)`;

            setTimeout(() => {
                pointer.classList.remove('pointer-bouncing'); 

                winnerText.textContent = `ELIMINATED: ${winnerData.name.toUpperCase()}! üíÄ`;
                
                pointerWinnerLabel.textContent = winnerData.name.toUpperCase();
                pointerWinnerLabel.classList.add('show-winner-label');

                resultBox.classList.add('death-glow'); 

                currentEliminationParticipants.splice(winningIndex, 1);
                wheelData = currentEliminationParticipants; 
                drawWheel(); 

                setTimeout(eliminationSpinCycle, 2000); 
            }, duration * 1000 + 50); 
        }

        function startEliminationMode() {
            if (isSpinning) return;

            const initialNames = namesInput.value
                .split('\n')
                .map(name => name.trim())
                .filter(name => name.length > 0);

            if (initialNames.length < 2) {
                winnerText.textContent = "Need at least two contestants for Deathmatch!";
                return;
            }

            spinButton.disabled = true;
            eliminationButton.disabled = true;
            namesInput.disabled = true;
            spinDurationInput.disabled = true;

            currentEliminationParticipants = initialNames.map((name, index) => ({
                name: name,
                color: VIBRANT_COLORS[index % VIBRANT_COLORS.length],
            }));
            
            wheelData = currentEliminationParticipants;
            drawWheel();

            eliminationSpinCycle();
        }


        // Event Listeners and Initialization
        document.addEventListener('DOMContentLoaded', async () => {
            await loadLogo();
            prepareWheelData();

            namesInput.addEventListener('input', prepareWheelData);
            spinButton.addEventListener('click', spinWheel);
            eliminationButton.addEventListener('click', startEliminationMode);

            const resizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    if (entry.target === document.getElementById('wheel-area')) {
                        const size = Math.min(entry.contentRect.width, entry.contentRect.height);
                        if (size > 0) {
                            const newSize = Math.min(size, 500); 
                            canvas.width = newSize;
                            canvas.height = newSize;
                            drawWheel(); 
                        }
                    }
                }
            });
            resizeObserver.observe(document.getElementById('wheel-area'));
        });
    </script>
</body>
</html>
