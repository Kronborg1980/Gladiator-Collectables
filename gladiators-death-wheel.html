<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gladiators Death Wheel</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base Dark/Tron Colors */
        :root {
            --tron-blue: #00FFFF;
            --tron-magenta: #FF00FF;
            --tron-red: #FF4500; /* For Death/Elimination */
            --dark-metal: #1a1a1a;
            --light-metal: #444444;
            --text-neon: #E0E0E0;
        }

        /* Utility Styles */
        .neon-text-glow {
            text-shadow: 0 0 5px #fff, 0 0 10px var(--tron-blue), 0 0 20px var(--tron-blue);
        }
        .death-glow {
            box-shadow: 0 0 15px var(--tron-red), inset 0 0 10px var(--tron-red);
            border-color: var(--tron-red) !important;
        }
        .success-glow {
            box-shadow: 0 0 15px #39FF14, inset 0 0 10px #39FF14;
            border-color: #39FF14 !important;
        }
        .metal-panel {
            background: linear-gradient(145deg, var(--dark-metal), #000000);
            border: 2px solid var(--light-metal);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5), inset 0 0 5px var(--light-metal);
        }
        
        /* WHEEL AND POINTER STYLES */
        #wheel-wrapper {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }
        
        #wheel-container {
            transition: transform 0s ease-out;
        }

        #wheel-canvas {
            border: 10px solid var(--light-metal); /* Simulated Metal Rim */
            border-radius: 50%;
            /* Intense Neon Glow for the Tron Effect */
            box-shadow: 0 0 30px var(--tron-blue), 0 0 10px var(--tron-blue);
        }

        #pointer {
            /* Realistic, heavier-looking metal pointer */
            position: absolute;
            top: -60px; /* Positioned higher to clear the wheel edge */
            width: 0;
            height: 0;
            border-left: 35px solid transparent; 
            border-right: 35px solid transparent; 
            border-top: 65px solid var(--tron-blue); 
            filter: drop-shadow(0 0 15px var(--tron-blue)); /* Stronger glow */
            z-index: 10;
            left: 50%;
            transform: translateX(-50%); 
            transform-origin: 50% 100%; 
        }

        #pointer-winner-label {
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 11;
            padding: 5px 12px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: bold;
            color: var(--dark-metal);
            background-color: #39FF14;
            opacity: 0;
            transition: opacity 0.3s ease-in;
        }

        .show-winner-label {
            opacity: 1 !important;
            box-shadow: 0 0 10px #39FF14, 0 0 20px #39FF14;
        }

        /* Pointer Animation (Kept from original) */
        @keyframes pointerBounce {
            0% { transform: translateX(-50%) rotate(-10deg); }
            100% { transform: translateX(-50%) rotate(10deg); }
        }
        .pointer-bouncing {
            animation: pointerBounce 0.1s infinite alternate;
        }

        /* Elimination Button Neon Red Style */
        #elimination-button {
            background-color: var(--tron-red);
            color: var(--text-neon);
            box-shadow: 0 0 15px var(--tron-red), 0 0 30px var(--tron-red);
            transition: all 0.3s;
        }
        #elimination-button:hover:not(:disabled) {
            transform: scale(1.02);
            box-shadow: 0 0 25px var(--tron-red), 0 0 40px var(--tron-red);
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-neon': '#00FFFF',   
                        'secondary-neon': '#FF00FF', 
                        'dark-bg': '#0A0A0A',       
                        'neutral-glow': '#E0E0E0', 
                    },
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-dark-bg min-h-screen p-4 font-sans flex flex-col items-center text-text-neon">

    <h1 class="text-5xl font-extrabold text-tron-red mt-4 mb-8 text-center neon-text-glow" style="color: var(--tron-red);">
        GLADIATORS DEATH WHEEL
    </h1>

    <div class="flex flex-col lg:flex-row w-full max-w-7xl gap-8">

        <div class="lg:w-1/3 p-6 rounded-xl shadow-lg h-fit metal-panel">
            <h2 class="text-3xl font-bold mb-4 text-primary-neon">Control Chamber</h2>

            <label for="names-input" class="block text-sm font-medium text-text-neon/80 mb-1">
                Contestants (One name per line):
            </label>
            <textarea id="names-input" rows="8" class="w-full p-3 border border-primary-neon/50 bg-gray-900 text-text-neon rounded-lg focus:ring-primary-neon focus:border-primary-neon transition duration-150 shadow-inner" placeholder="E.g.,&#10;Kaelen&#10;Maximus&#10;Zeva&#10;Orion&#10;Aura">Alice
Bob
Charlie
Diana
Eve</textarea>

            <label for="spin-duration" class="block text-sm font-medium text-text-neon/80 mt-4 mb-1">
                Spin Duration (seconds):
            </label>
            <input type="number" id="spin-duration" value="5" min="1" max="60" class="w-full p-3 border border-primary-neon/50 bg-gray-900 text-text-neon rounded-lg focus:ring-primary-neon focus:border-primary-neon transition duration-150 shadow-inner text-center" />

            <button id="spin-button" class="w-full mt-6 py-4 px-4 bg-secondary-neon text-dark-metal font-extrabold rounded-xl shadow-md hover:opacity-90 transition duration-300 disabled:opacity-50 disabled:cursor-not-allowed" style="box-shadow: 0 0 15px var(--tron-magenta), 0 0 30px var(--tron-magenta);">
                THE FATE SPIN
            </button>
            
            <button id="elimination-button" class="w-full mt-4 py-4 px-4 font-extrabold rounded-xl shadow-md disabled:opacity-50 disabled:cursor-not-allowed">
                INITIATE DEATHMATCH 
            </button>
        </div>

        <div class="lg:w-2/3 p-6 rounded-xl shadow-lg flex flex-col items-center metal-panel">
            <div id="result-box" class="w-full text-center mb-6 h-24 flex flex-col items-center justify-center rounded-lg border-4 border-dashed border-tron-blue/80 bg-dark-metal/50 p-2" style="box-shadow: 0 0 10px var(--tron-blue), inset 0 0 5px var(--tron-blue);">
                <p class="text-xl font-bold text-tron-blue/90">CURRENT STATUS:</p>
                <p id="winner-text" class="text-2xl font-extrabold text-tron-blue/90">Awaits the Gladiator's Choice.</p>
            </div>

            <div id="wheel-area" class="w-full max-w-lg aspect-square flex justify-center items-center">
                <div id="wheel-wrapper">
                    <div id="pointer"></div> 
                    <div id="pointer-winner-label" class="hidden"></div>
                    
                    <div id="wheel-container" style="width: 100%; height: 100%;">
                        <canvas id="wheel-canvas" class="w-full h-full"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Constants
        const CANVAS_SIZE = 500;
        const LOGO_URL = 'https://60fb7b08eaf293096e8c.cdn6.editmysite.com/uploads/b/60fb7b08eaf293096e8cb3f63df9e65735b8a1ee75f6d23d21eaed2115dfa2e6/IMG_7388_1701827680.jpeg?width=2400&optimize=medium';
        const ELIMINATION_SPIN_DURATION = 5; 

        // Distinct, neon colors for the segments (Tron theme)
        const VIBRANT_COLORS = [
            '#00FFFF', // Cyan
            '#FF00FF', // Magenta
            '#39FF14', // Neon Green
            '#FFFF00', // Neon Yellow
            '#FF1493', // Deep Pink
            '#1E90FF', // Dodger Blue
            '#9370DB', // Medium Purple
            '#00FA9A', // Medium Spring Green
            '#FF4500', // Orange Red
            '#7B68EE', // Medium Slate Blue
            '#FF6347', // Tomato
            '#00FF00', // Lime
            '#D8BFD8', // Thistle
            '#ADD8E6', // Light Blue
            '#F08080'  // Light Coral
        ];

        // DOM Elements
        const canvas = document.getElementById('wheel-canvas');
        const ctx = canvas.getContext('2d');
        const wheelContainer = document.getElementById('wheel-container');
        const pointer = document.getElementById('pointer'); 
        const pointerWinnerLabel = document.getElementById('pointer-winner-label'); 
        const namesInput = document.getElementById('names-input');
        const spinDurationInput = document.getElementById('spin-duration');
        const spinButton = document.getElementById('spin-button');
        const eliminationButton = document.getElementById('elimination-button');
        const winnerText = document.getElementById('winner-text');
        const resultBox = document.getElementById('result-box');

        // State
        let wheelData = [];
        let logoImage = null;
        let isSpinning = false;
        let currentEliminationParticipants = [];

        // Set initial canvas size 
        canvas.width = CANVAS_SIZE;
        canvas.height = CANVAS_SIZE;

        /**
         * Loads the logo image from the provided URL.
         */
        function loadLogo() {
            return new Promise((resolve) => {
                const img = new Image();
                img.crossOrigin = "anonymous";
                img.onload = () => {
                    logoImage = img;
                    resolve(true);
                };
                img.onerror = () => {
                    console.error("Failed to load logo image. Using text placeholder.");
                    resolve(false);
                };
                img.src = LOGO_URL;
            });
        }

        /**
         * Parses the names input and prepares the wheel data structure.
         */
        function prepareWheelData() {
            const names = namesInput.value
                .split('\n')
                .map(name => name.trim())
                .filter(name => name.length > 0);

            if (names.length === 0) {
                wheelData = [];
                drawWheel();
                return;
            }

            wheelData = names.map((name, index) => ({
                name: name,
                color: VIBRANT_COLORS[index % VIBRANT_COLORS.length],
            }));
            
            drawWheel();
        }

        /**
         * Draws the entire wheel on the canvas.
         */
        function drawWheel() {
            const size = canvas.width;
            const dataToDraw = wheelData;

            if (dataToDraw.length === 0) {
                ctx.clearRect(0, 0, size, size);
                winnerText.textContent = "Awaits the Gladiator's Choice.";
                return;
            }

            const centerX = size / 2;
            const centerY = size / 2;
            const radius = size / 2 - 10;

            const segmentAngle = 2 * Math.PI / dataToDraw.length;
            let currentAngle = 0;

            ctx.clearRect(0, 0, size, size);

            // 1. Draw Segments and Text
            dataToDraw.forEach((item) => {
                const startAngle = currentAngle;
                const endAngle = currentAngle + segmentAngle;

                // Draw Segment
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = item.color;
                ctx.fill();

                // Draw Text
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(startAngle + segmentAngle / 2);

                ctx.fillStyle = '#0A0A0A'; // Dark text for contrast
                ctx.font = `bold ${Math.floor(size * 0.032)}px Inter`; 
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';

                const textX = radius * 0.9;
                ctx.fillText(item.name.toUpperCase(), textX, 0);

                ctx.restore();
                currentAngle = endAngle;
            });

            // 2. Draw Pegs (Needles)
            const numPegs = dataToDraw.length;
            const pegRadius = radius; 
            const pegSize = size * 0.015; // Slightly larger pegs

            // Draw pegs at the end of each segment
            for (let i = 0; i < numPegs; i++) {
                // Angle is the end of the segment
                const angle = (i + 1) * segmentAngle;

                const x = centerX + pegRadius * Math.cos(angle);
                const y = centerY + pegRadius * Math.sin(angle);

                ctx.save();
                
                // Peg Glow (Tron Blue)
                ctx.beginPath();
                ctx.arc(x, y, pegSize, 0, 2 * Math.PI);
                ctx.fillStyle = '#FFFFFF'; 
                ctx.shadowColor = 'var(--tron-blue)';
                ctx.shadowBlur = 15;
                ctx.fill();

                // Peg Core (Darker metal look)
                ctx.beginPath();
                ctx.arc(x, y, pegSize * 0.6, 0, 2 * Math.PI);
                ctx.fillStyle = 'var(--dark-metal)'; 
                ctx.shadowBlur = 0; 
                ctx.fill();

                ctx.restore();
            }
            ctx.shadowBlur = 0;

            // 3. Draw Center Hole (Glow Circle)
            const logoRadius = radius * 0.25;
            // Neon border (Magenta)
            ctx.beginPath();
            ctx.arc(centerX, centerY, logoRadius + 10, 0, 2 * Math.PI);
            ctx.fillStyle = 'var(--tron-magenta)';
            ctx.shadowColor = 'var(--tron-magenta)';
            ctx.shadowBlur = 10;
            ctx.fill();

            // Inner metal circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, logoRadius, 0, 2 * Math.PI);
            ctx.fillStyle = 'var(--light-metal)';
            ctx.shadowBlur = 0;
            ctx.fill();
            
            // 4. Draw Logo/Placeholder
            if (logoImage) {
                const imgSize = logoRadius * 1.8;
                ctx.save();
                ctx.beginPath();
                ctx.arc(centerX, centerY, logoRadius, 0, Math.PI * 2);
                ctx.clip(); 
                ctx.drawImage(logoImage, centerX - imgSize / 2, centerY - imgSize / 2, imgSize, imgSize);
                ctx.restore();
            } else {
                ctx.fillStyle = 'var(--tron-blue)';
                ctx.font = `bold ${Math.floor(size * 0.04)}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText("LOGO", centerX, centerY);
            }
        }

        /**
         * Initiates a single standard spin.
         */
        function spinWheel() {
            if (isSpinning || wheelData.length === 0) return;
            isSpinning = true;
            spinButton.disabled = true;
            eliminationButton.disabled = true; 
            namesInput.disabled = true;
            spinDurationInput.disabled = true;

            winnerText.textContent = "Spinning...";
            pointer.classList.add('pointer-bouncing'); 
            pointerWinnerLabel.classList.remove('show-winner-label'); 
            
            resultBox.classList.remove('success-glow', 'death-glow');
            winnerText.classList.add('text-primary-neon/90');

            let duration = parseFloat(spinDurationInput.value) || 5;
            if (duration < 1 || duration > 60) {
                spinDurationInput.value = 5;
                duration = 5;
            }

            const dataToSpin = wheelData;
            const numSegments = dataToSpin.length;
            const segmentAngleDegrees = 360 / numSegments;

            // 1. Get current rotation
            const currentTransform = wheelContainer.style.transform;
            let currentRotation = 0;
            const match = currentTransform.match(/rotate\(([-+]?\d*\.?\d+)/);
            if (match) {
                currentRotation = parseFloat(match[1]);
            }

            // 2. Calculate a random winning index
            const winningIndex = Math.floor(Math.random() * numSegments);
            const winnerName = dataToSpin[winningIndex].name;

            // 3. Determine the target rotation angle (in degrees)
            // Pointer is at 270 degrees (straight up). Segments start at 0 (right) and increase clockwise.
            // We want the *center* of the winning segment to align with the *pointer*.
            let targetSegmentMidpoint = winningIndex * segmentAngleDegrees + (segmentAngleDegrees / 2);
            const pointerAngle = 270; 
            let landingAngleOffset = pointerAngle - targetSegmentMidpoint;

            // Add small jitter for realism
            const MAX_JITTER_RANGE = segmentAngleDegrees * 0.4; 
            const randomJitterOffset = (Math.random() * (2 * MAX_JITTER_RANGE)) - MAX_JITTER_RANGE;
            landingAngleOffset += randomJitterOffset;

            const normalizedCurrentRotation = currentRotation % 360;
            let deltaRotation = landingAngleOffset - normalizedCurrentRotation;

            if (deltaRotation < 0) {
                deltaRotation += 360;
            }

            const fullRotations = 5;
            const totalRotation = currentRotation + (fullRotations * 360) + deltaRotation;
            
            // Apply the transformation and transition for the spin animation
            wheelContainer.style.transition = `transform ${duration}s cubic-bezier(0.1, 0.7, 0.4, 1)`;
            wheelContainer.style.transform = `rotate(${totalRotation}deg)`;

            // 4. Announce winner after the duration
            setTimeout(() => {
                pointer.classList.remove('pointer-bouncing'); 

                winnerText.textContent = `WINNER: ${winnerName.toUpperCase()}! üèÜ`;
                
                pointerWinnerLabel.textContent = winnerName.toUpperCase();
                pointerWinnerLabel.classList.add('show-winner-label');

                // Switch to success glow state (Neon Green)
                resultBox.classList.add('success-glow');
                winnerText.classList.remove('text-primary-neon/90');
                winnerText.classList.add('text-text-neon');

                isSpinning = false;
                spinButton.disabled = false;
                eliminationButton.disabled = false;
                namesInput.disabled = false;
                spinDurationInput.disabled = false;
            }, duration * 1000 + 50);
        }

        /**
         * Recursive function to handle one spin, elimination, and setup for the next.
         */
        function eliminationSpinCycle() {
            if (currentEliminationParticipants.length <= 1) {
                // Final winner
                const finalWinner = currentEliminationParticipants[0];
                winnerText.textContent = `ULTIMATE CHAMPION: ${finalWinner ? finalWinner.name.toUpperCase() : 'NO ONE'} WINS! üëë`;
                
                // Final winner glow (Success Green)
                resultBox.classList.remove('death-glow');
                resultBox.classList.add('success-glow');
                winnerText.classList.remove('text-primary-neon/90');
                winnerText.classList.add('text-text-neon');

                // Reset state and re-enable controls
                isSpinning = false;
                spinButton.disabled = false;
                eliminationButton.disabled = false;
                namesInput.disabled = false;
                spinDurationInput.disabled = false;
                pointerWinnerLabel.classList.remove('show-winner-label');
                return;
            }

            // Set state for spinning
            isSpinning = true;
            winnerText.textContent = `ELIMINATION ROUND: ${currentEliminationParticipants.length} remain...`;
            pointer.classList.add('pointer-bouncing'); 
            pointerWinnerLabel.classList.remove('show-winner-label'); 
            
            // Reset visual feedback to elimination state (Red)
            resultBox.classList.remove('success-glow');
            winnerText.classList.add('text-primary-neon/90');

            const duration = ELIMINATION_SPIN_DURATION; 

            const dataToSpin = currentEliminationParticipants;
            const numSegments = dataToSpin.length;
            const segmentAngleDegrees = 360 / numSegments;

            // 1. Calculate spin and winner
            const winningIndex = Math.floor(Math.random() * numSegments);
            const winnerData = dataToSpin[winningIndex];

            // 2. Determine target rotation angle
            const currentTransform = wheelContainer.style.transform;
            let currentRotation = 0;
            const match = currentTransform.match(/rotate\(([-+]?\d*\.?\d+)/);
            if (match) {
                currentRotation = parseFloat(match[1]);
            }

            let targetSegmentMidpoint = winningIndex * segmentAngleDegrees + (segmentAngleDegrees / 2);
            const pointerAngle = 270; 
            let landingAngleOffset = pointerAngle - targetSegmentMidpoint;

            const MAX_JITTER_RANGE = segmentAngleDegrees * 0.4; 
            const randomJitterOffset = (Math.random() * (2 * MAX_JITTER_RANGE)) - MAX_JITTER_RANGE;
            landingAngleOffset += randomJitterOffset;

            const normalizedCurrentRotation = currentRotation % 360;
            let deltaRotation = landingAngleOffset - normalizedCurrentRotation;

            if (deltaRotation < 0) {
                deltaRotation += 360;
            }

            const fullRotations = 5;
            const totalRotation = currentRotation + (fullRotations * 360) + deltaRotation;
            
            wheelContainer.style.transition = `transform ${duration}s cubic-bezier(0.1, 0.7, 0.4, 1)`;
            wheelContainer.style.transform = `rotate(${totalRotation}deg)`;

            // 3. Announce result and eliminate
            setTimeout(() => {
                pointer.classList.remove('pointer-bouncing'); 

                // Announce who is ELIMINATED
                winnerText.textContent = `ELIMINATED: ${winnerData.name.toUpperCase()}! üíÄ`;
                
                pointerWinnerLabel.textContent = winnerData.name.toUpperCase();
                pointerWinnerLabel.classList.add('show-winner-label');

                // Highlight the elimination result (Neon Red)
                resultBox.classList.add('death-glow'); 
                winnerText.classList.remove('text-primary-neon/90');
                winnerText.classList.add('text-text-neon');

                // REMOVE THE ELIMINATED CONTESTANT
                currentEliminationParticipants.splice(winningIndex, 1);
                
                // REDRAW the wheel with the remaining people for the next spin's preparation
                wheelData = currentEliminationParticipants; 
                drawWheel(); 

                // After a brief pause, start the next spin cycle
                setTimeout(eliminationSpinCycle, 2000); 
            }, duration * 1000 + 50); 
        }

        /**
         * Initializes the state for elimination mode.
         */
        function startEliminationMode() {
            if (isSpinning) return;

            const initialNames = namesInput.value
                .split('\n')
                .map(name => name.trim())
                .filter(name => name.length > 0);

            if (initialNames.length < 2) {
                winnerText.textContent = "Need at least two contestants for Deathmatch!";
                return;
            }

            // Disable controls for the duration of the entire sequence
            spinButton.disabled = true;
            eliminationButton.disabled = true;
            namesInput.disabled = true;
            spinDurationInput.disabled = true;

            // Reset and prepare the participants array for elimination
            currentEliminationParticipants = initialNames.map((name, index) => ({
                name: name,
                color: VIBRANT_COLORS[index % VIBRANT_COLORS.length],
            }));
            
            // Set wheelData to the initial list and draw for the first spin
            wheelData = currentEliminationParticipants;
            drawWheel();

            // Start the recursive spin process
            eliminationSpinCycle();
        }


        // Event Listeners and Initialization
        document.addEventListener('DOMContentLoaded', async () => {
            await loadLogo();
            prepareWheelData();

            namesInput.addEventListener('input', prepareWheelData);
            spinButton.addEventListener('click', spinWheel);
            eliminationButton.addEventListener('click', startEliminationMode);

            // Set the winning text to a non-neon color so the neon only shows in the result box when active
            winnerText.style.color = 'var(--text-neon)';

            const resizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    if (entry.target === document.getElementById('wheel-area')) {
                        const size = Math.min(entry.contentRect.width, entry.contentRect.height);
                        if (size > 0) {
                            const newSize = Math.min(size, 500); 
                            canvas.width = newSize;
                            canvas.height = newSize;
                            drawWheel(); 
                        }
                    }
                }
            });
            resizeObserver.observe(document.getElementById('wheel-area'));
        });
    </script>
</body>
</html>
